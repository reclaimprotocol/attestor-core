// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.5.0
//   protoc               v6.31.1
// source: tee-bundle.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "teeproto";

/** Signature wrapper used everywhere */
export enum BodyType {
  BODY_TYPE_UNSPECIFIED = 0,
  BODY_TYPE_K_OUTPUT = 1,
  BODY_TYPE_T_OUTPUT = 2,
  UNRECOGNIZED = -1,
}

export function bodyTypeFromJSON(object: any): BodyType {
  switch (object) {
    case 0:
    case "BODY_TYPE_UNSPECIFIED":
      return BodyType.BODY_TYPE_UNSPECIFIED;
    case 1:
    case "BODY_TYPE_K_OUTPUT":
      return BodyType.BODY_TYPE_K_OUTPUT;
    case 2:
    case "BODY_TYPE_T_OUTPUT":
      return BodyType.BODY_TYPE_T_OUTPUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BodyType.UNRECOGNIZED;
  }
}

export function bodyTypeToJSON(object: BodyType): string {
  switch (object) {
    case BodyType.BODY_TYPE_UNSPECIFIED:
      return "BODY_TYPE_UNSPECIFIED";
    case BodyType.BODY_TYPE_K_OUTPUT:
      return "BODY_TYPE_K_OUTPUT";
    case BodyType.BODY_TYPE_T_OUTPUT:
      return "BODY_TYPE_T_OUTPUT";
    case BodyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Common structures */
export interface RequestRedactionRange {
  start: number;
  length: number;
  /** Values: "sensitive" or "sensitive_proof" */
  type: string;
  /** Optional */
  redactionBytes: Uint8Array;
}

export interface ResponseRedactionRange {
  start: number;
  length: number;
}

export interface SignedRedactedDecryptionStream {
  redactedStream: Uint8Array;
  seqNum: number;
}

/** Handshake secrets disclosed for verification/display */
export interface HandshakeSecrets {
  handshakeKey: Uint8Array;
  handshakeIv: Uint8Array;
  /** uint16 fits here */
  cipherSuite: number;
  algorithm: string;
}

/** Commitment opening for proof stream */
export interface Opening {
  /** Str_SP */
  proofStream: Uint8Array;
  /** K_SP */
  proofKey: Uint8Array;
}

/** Deterministically serialized payloads to be signed by TEEs */
export interface KOutputPayload {
  /** For single request-response mode */
  redactedRequest: Uint8Array;
  requestRedactionRanges: RequestRedactionRange[];
  /** from TEE_K */
  redactedStreams: SignedRedactedDecryptionStream[];
  /** TLS handshake packets observed by TEE_K */
  packets: Uint8Array[];
  responseRedactionRanges: ResponseRedactionRange[];
}

export interface TOutputPayload {
  /** TLS packets observed by TEE_T */
  packets: Uint8Array[];
}

/** Attestation report with structured data */
export interface AttestationReport {
  /** "nitro" or "gcp" */
  type: string;
  /** raw provider-specific attestation bytes */
  report: Uint8Array;
}

export interface SignedMessage {
  bodyType: BodyType;
  /** serialized deterministic KOutputPayload or TOutputPayload */
  body: Uint8Array;
  /** DER-encoded public key (standalone mode only) */
  publicKey: Uint8Array;
  /** signature over body bytes */
  signature: Uint8Array;
  /** full attestation (enclave mode only) */
  attestationReport: AttestationReport | undefined;
}

/** Single artefact produced by client for offline verification */
export interface VerificationBundlePB {
  /** optional */
  handshakeKeys:
    | HandshakeSecrets
    | undefined;
  /** Signed transcripts */
  teekSigned:
    | SignedMessage
    | undefined;
  /** BODY_TYPE_T_OUTPUT */
  teetSigned:
    | SignedMessage
    | undefined;
  /** Commitment opening for proof ranges */
  opening:
    | Opening
    | undefined;
  /** Optional attestation documents */
  attestationTeeK: Uint8Array;
  attestationTeeT: Uint8Array;
}

function createBaseRequestRedactionRange(): RequestRedactionRange {
  return { start: 0, length: 0, type: "", redactionBytes: new Uint8Array(0) };
}

export const RequestRedactionRange: MessageFns<RequestRedactionRange> = {
  encode(message: RequestRedactionRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.length !== 0) {
      writer.uint32(16).int32(message.length);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.redactionBytes.length !== 0) {
      writer.uint32(34).bytes(message.redactionBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestRedactionRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestRedactionRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.start = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.length = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.redactionBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestRedactionRange {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      redactionBytes: isSet(object.redactionBytes) ? bytesFromBase64(object.redactionBytes) : new Uint8Array(0),
    };
  },

  toJSON(message: RequestRedactionRange): unknown {
    const obj: any = {};
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.redactionBytes.length !== 0) {
      obj.redactionBytes = base64FromBytes(message.redactionBytes);
    }
    return obj;
  },

  create(base?: DeepPartial<RequestRedactionRange>): RequestRedactionRange {
    return RequestRedactionRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestRedactionRange>): RequestRedactionRange {
    const message = createBaseRequestRedactionRange();
    message.start = object.start ?? 0;
    message.length = object.length ?? 0;
    message.type = object.type ?? "";
    message.redactionBytes = object.redactionBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseResponseRedactionRange(): ResponseRedactionRange {
  return { start: 0, length: 0 };
}

export const ResponseRedactionRange: MessageFns<ResponseRedactionRange> = {
  encode(message: ResponseRedactionRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.length !== 0) {
      writer.uint32(16).int32(message.length);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseRedactionRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseRedactionRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.start = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.length = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseRedactionRange {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
    };
  },

  toJSON(message: ResponseRedactionRange): unknown {
    const obj: any = {};
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    return obj;
  },

  create(base?: DeepPartial<ResponseRedactionRange>): ResponseRedactionRange {
    return ResponseRedactionRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResponseRedactionRange>): ResponseRedactionRange {
    const message = createBaseResponseRedactionRange();
    message.start = object.start ?? 0;
    message.length = object.length ?? 0;
    return message;
  },
};

function createBaseSignedRedactedDecryptionStream(): SignedRedactedDecryptionStream {
  return { redactedStream: new Uint8Array(0), seqNum: 0 };
}

export const SignedRedactedDecryptionStream: MessageFns<SignedRedactedDecryptionStream> = {
  encode(message: SignedRedactedDecryptionStream, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.redactedStream.length !== 0) {
      writer.uint32(10).bytes(message.redactedStream);
    }
    if (message.seqNum !== 0) {
      writer.uint32(16).uint64(message.seqNum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignedRedactedDecryptionStream {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedRedactedDecryptionStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.redactedStream = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.seqNum = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedRedactedDecryptionStream {
    return {
      redactedStream: isSet(object.redactedStream) ? bytesFromBase64(object.redactedStream) : new Uint8Array(0),
      seqNum: isSet(object.seqNum) ? globalThis.Number(object.seqNum) : 0,
    };
  },

  toJSON(message: SignedRedactedDecryptionStream): unknown {
    const obj: any = {};
    if (message.redactedStream.length !== 0) {
      obj.redactedStream = base64FromBytes(message.redactedStream);
    }
    if (message.seqNum !== 0) {
      obj.seqNum = Math.round(message.seqNum);
    }
    return obj;
  },

  create(base?: DeepPartial<SignedRedactedDecryptionStream>): SignedRedactedDecryptionStream {
    return SignedRedactedDecryptionStream.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedRedactedDecryptionStream>): SignedRedactedDecryptionStream {
    const message = createBaseSignedRedactedDecryptionStream();
    message.redactedStream = object.redactedStream ?? new Uint8Array(0);
    message.seqNum = object.seqNum ?? 0;
    return message;
  },
};

function createBaseHandshakeSecrets(): HandshakeSecrets {
  return { handshakeKey: new Uint8Array(0), handshakeIv: new Uint8Array(0), cipherSuite: 0, algorithm: "" };
}

export const HandshakeSecrets: MessageFns<HandshakeSecrets> = {
  encode(message: HandshakeSecrets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.handshakeKey.length !== 0) {
      writer.uint32(10).bytes(message.handshakeKey);
    }
    if (message.handshakeIv.length !== 0) {
      writer.uint32(18).bytes(message.handshakeIv);
    }
    if (message.cipherSuite !== 0) {
      writer.uint32(24).uint32(message.cipherSuite);
    }
    if (message.algorithm !== "") {
      writer.uint32(34).string(message.algorithm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandshakeSecrets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandshakeSecrets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.handshakeKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.handshakeIv = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cipherSuite = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandshakeSecrets {
    return {
      handshakeKey: isSet(object.handshakeKey) ? bytesFromBase64(object.handshakeKey) : new Uint8Array(0),
      handshakeIv: isSet(object.handshakeIv) ? bytesFromBase64(object.handshakeIv) : new Uint8Array(0),
      cipherSuite: isSet(object.cipherSuite) ? globalThis.Number(object.cipherSuite) : 0,
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
    };
  },

  toJSON(message: HandshakeSecrets): unknown {
    const obj: any = {};
    if (message.handshakeKey.length !== 0) {
      obj.handshakeKey = base64FromBytes(message.handshakeKey);
    }
    if (message.handshakeIv.length !== 0) {
      obj.handshakeIv = base64FromBytes(message.handshakeIv);
    }
    if (message.cipherSuite !== 0) {
      obj.cipherSuite = Math.round(message.cipherSuite);
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    return obj;
  },

  create(base?: DeepPartial<HandshakeSecrets>): HandshakeSecrets {
    return HandshakeSecrets.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HandshakeSecrets>): HandshakeSecrets {
    const message = createBaseHandshakeSecrets();
    message.handshakeKey = object.handshakeKey ?? new Uint8Array(0);
    message.handshakeIv = object.handshakeIv ?? new Uint8Array(0);
    message.cipherSuite = object.cipherSuite ?? 0;
    message.algorithm = object.algorithm ?? "";
    return message;
  },
};

function createBaseOpening(): Opening {
  return { proofStream: new Uint8Array(0), proofKey: new Uint8Array(0) };
}

export const Opening: MessageFns<Opening> = {
  encode(message: Opening, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proofStream.length !== 0) {
      writer.uint32(10).bytes(message.proofStream);
    }
    if (message.proofKey.length !== 0) {
      writer.uint32(18).bytes(message.proofKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Opening {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpening();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofStream = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proofKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Opening {
    return {
      proofStream: isSet(object.proofStream) ? bytesFromBase64(object.proofStream) : new Uint8Array(0),
      proofKey: isSet(object.proofKey) ? bytesFromBase64(object.proofKey) : new Uint8Array(0),
    };
  },

  toJSON(message: Opening): unknown {
    const obj: any = {};
    if (message.proofStream.length !== 0) {
      obj.proofStream = base64FromBytes(message.proofStream);
    }
    if (message.proofKey.length !== 0) {
      obj.proofKey = base64FromBytes(message.proofKey);
    }
    return obj;
  },

  create(base?: DeepPartial<Opening>): Opening {
    return Opening.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Opening>): Opening {
    const message = createBaseOpening();
    message.proofStream = object.proofStream ?? new Uint8Array(0);
    message.proofKey = object.proofKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseKOutputPayload(): KOutputPayload {
  return {
    redactedRequest: new Uint8Array(0),
    requestRedactionRanges: [],
    redactedStreams: [],
    packets: [],
    responseRedactionRanges: [],
  };
}

export const KOutputPayload: MessageFns<KOutputPayload> = {
  encode(message: KOutputPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.redactedRequest.length !== 0) {
      writer.uint32(10).bytes(message.redactedRequest);
    }
    for (const v of message.requestRedactionRanges) {
      RequestRedactionRange.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.redactedStreams) {
      SignedRedactedDecryptionStream.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.packets) {
      writer.uint32(34).bytes(v!);
    }
    for (const v of message.responseRedactionRanges) {
      ResponseRedactionRange.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KOutputPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKOutputPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.redactedRequest = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestRedactionRanges.push(RequestRedactionRange.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.redactedStreams.push(SignedRedactedDecryptionStream.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.packets.push(reader.bytes());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.responseRedactionRanges.push(ResponseRedactionRange.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KOutputPayload {
    return {
      redactedRequest: isSet(object.redactedRequest) ? bytesFromBase64(object.redactedRequest) : new Uint8Array(0),
      requestRedactionRanges: globalThis.Array.isArray(object?.requestRedactionRanges)
        ? object.requestRedactionRanges.map((e: any) => RequestRedactionRange.fromJSON(e))
        : [],
      redactedStreams: globalThis.Array.isArray(object?.redactedStreams)
        ? object.redactedStreams.map((e: any) => SignedRedactedDecryptionStream.fromJSON(e))
        : [],
      packets: globalThis.Array.isArray(object?.packets) ? object.packets.map((e: any) => bytesFromBase64(e)) : [],
      responseRedactionRanges: globalThis.Array.isArray(object?.responseRedactionRanges)
        ? object.responseRedactionRanges.map((e: any) => ResponseRedactionRange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: KOutputPayload): unknown {
    const obj: any = {};
    if (message.redactedRequest.length !== 0) {
      obj.redactedRequest = base64FromBytes(message.redactedRequest);
    }
    if (message.requestRedactionRanges?.length) {
      obj.requestRedactionRanges = message.requestRedactionRanges.map((e) => RequestRedactionRange.toJSON(e));
    }
    if (message.redactedStreams?.length) {
      obj.redactedStreams = message.redactedStreams.map((e) => SignedRedactedDecryptionStream.toJSON(e));
    }
    if (message.packets?.length) {
      obj.packets = message.packets.map((e) => base64FromBytes(e));
    }
    if (message.responseRedactionRanges?.length) {
      obj.responseRedactionRanges = message.responseRedactionRanges.map((e) => ResponseRedactionRange.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<KOutputPayload>): KOutputPayload {
    return KOutputPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KOutputPayload>): KOutputPayload {
    const message = createBaseKOutputPayload();
    message.redactedRequest = object.redactedRequest ?? new Uint8Array(0);
    message.requestRedactionRanges = object.requestRedactionRanges?.map((e) => RequestRedactionRange.fromPartial(e)) ||
      [];
    message.redactedStreams = object.redactedStreams?.map((e) => SignedRedactedDecryptionStream.fromPartial(e)) || [];
    message.packets = object.packets?.map((e) => e) || [];
    message.responseRedactionRanges =
      object.responseRedactionRanges?.map((e) => ResponseRedactionRange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTOutputPayload(): TOutputPayload {
  return { packets: [] };
}

export const TOutputPayload: MessageFns<TOutputPayload> = {
  encode(message: TOutputPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.packets) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TOutputPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTOutputPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packets.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TOutputPayload {
    return {
      packets: globalThis.Array.isArray(object?.packets) ? object.packets.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: TOutputPayload): unknown {
    const obj: any = {};
    if (message.packets?.length) {
      obj.packets = message.packets.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TOutputPayload>): TOutputPayload {
    return TOutputPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TOutputPayload>): TOutputPayload {
    const message = createBaseTOutputPayload();
    message.packets = object.packets?.map((e) => e) || [];
    return message;
  },
};

function createBaseAttestationReport(): AttestationReport {
  return { type: "", report: new Uint8Array(0) };
}

export const AttestationReport: MessageFns<AttestationReport> = {
  encode(message: AttestationReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.report.length !== 0) {
      writer.uint32(18).bytes(message.report);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttestationReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttestationReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.report = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttestationReport {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      report: isSet(object.report) ? bytesFromBase64(object.report) : new Uint8Array(0),
    };
  },

  toJSON(message: AttestationReport): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.report.length !== 0) {
      obj.report = base64FromBytes(message.report);
    }
    return obj;
  },

  create(base?: DeepPartial<AttestationReport>): AttestationReport {
    return AttestationReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttestationReport>): AttestationReport {
    const message = createBaseAttestationReport();
    message.type = object.type ?? "";
    message.report = object.report ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSignedMessage(): SignedMessage {
  return {
    bodyType: 0,
    body: new Uint8Array(0),
    publicKey: new Uint8Array(0),
    signature: new Uint8Array(0),
    attestationReport: undefined,
  };
}

export const SignedMessage: MessageFns<SignedMessage> = {
  encode(message: SignedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bodyType !== 0) {
      writer.uint32(8).int32(message.bodyType);
    }
    if (message.body.length !== 0) {
      writer.uint32(18).bytes(message.body);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    if (message.signature.length !== 0) {
      writer.uint32(34).bytes(message.signature);
    }
    if (message.attestationReport !== undefined) {
      AttestationReport.encode(message.attestationReport, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bodyType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.attestationReport = AttestationReport.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedMessage {
    return {
      bodyType: isSet(object.bodyType) ? bodyTypeFromJSON(object.bodyType) : 0,
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      attestationReport: isSet(object.attestationReport)
        ? AttestationReport.fromJSON(object.attestationReport)
        : undefined,
    };
  },

  toJSON(message: SignedMessage): unknown {
    const obj: any = {};
    if (message.bodyType !== 0) {
      obj.bodyType = bodyTypeToJSON(message.bodyType);
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.attestationReport !== undefined) {
      obj.attestationReport = AttestationReport.toJSON(message.attestationReport);
    }
    return obj;
  },

  create(base?: DeepPartial<SignedMessage>): SignedMessage {
    return SignedMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedMessage>): SignedMessage {
    const message = createBaseSignedMessage();
    message.bodyType = object.bodyType ?? 0;
    message.body = object.body ?? new Uint8Array(0);
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.attestationReport = (object.attestationReport !== undefined && object.attestationReport !== null)
      ? AttestationReport.fromPartial(object.attestationReport)
      : undefined;
    return message;
  },
};

function createBaseVerificationBundlePB(): VerificationBundlePB {
  return {
    handshakeKeys: undefined,
    teekSigned: undefined,
    teetSigned: undefined,
    opening: undefined,
    attestationTeeK: new Uint8Array(0),
    attestationTeeT: new Uint8Array(0),
  };
}

export const VerificationBundlePB: MessageFns<VerificationBundlePB> = {
  encode(message: VerificationBundlePB, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.handshakeKeys !== undefined) {
      HandshakeSecrets.encode(message.handshakeKeys, writer.uint32(10).fork()).join();
    }
    if (message.teekSigned !== undefined) {
      SignedMessage.encode(message.teekSigned, writer.uint32(18).fork()).join();
    }
    if (message.teetSigned !== undefined) {
      SignedMessage.encode(message.teetSigned, writer.uint32(26).fork()).join();
    }
    if (message.opening !== undefined) {
      Opening.encode(message.opening, writer.uint32(34).fork()).join();
    }
    if (message.attestationTeeK.length !== 0) {
      writer.uint32(82).bytes(message.attestationTeeK);
    }
    if (message.attestationTeeT.length !== 0) {
      writer.uint32(90).bytes(message.attestationTeeT);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerificationBundlePB {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerificationBundlePB();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.handshakeKeys = HandshakeSecrets.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.teekSigned = SignedMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.teetSigned = SignedMessage.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.opening = Opening.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.attestationTeeK = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.attestationTeeT = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerificationBundlePB {
    return {
      handshakeKeys: isSet(object.handshakeKeys) ? HandshakeSecrets.fromJSON(object.handshakeKeys) : undefined,
      teekSigned: isSet(object.teekSigned) ? SignedMessage.fromJSON(object.teekSigned) : undefined,
      teetSigned: isSet(object.teetSigned) ? SignedMessage.fromJSON(object.teetSigned) : undefined,
      opening: isSet(object.opening) ? Opening.fromJSON(object.opening) : undefined,
      attestationTeeK: isSet(object.attestationTeeK) ? bytesFromBase64(object.attestationTeeK) : new Uint8Array(0),
      attestationTeeT: isSet(object.attestationTeeT) ? bytesFromBase64(object.attestationTeeT) : new Uint8Array(0),
    };
  },

  toJSON(message: VerificationBundlePB): unknown {
    const obj: any = {};
    if (message.handshakeKeys !== undefined) {
      obj.handshakeKeys = HandshakeSecrets.toJSON(message.handshakeKeys);
    }
    if (message.teekSigned !== undefined) {
      obj.teekSigned = SignedMessage.toJSON(message.teekSigned);
    }
    if (message.teetSigned !== undefined) {
      obj.teetSigned = SignedMessage.toJSON(message.teetSigned);
    }
    if (message.opening !== undefined) {
      obj.opening = Opening.toJSON(message.opening);
    }
    if (message.attestationTeeK.length !== 0) {
      obj.attestationTeeK = base64FromBytes(message.attestationTeeK);
    }
    if (message.attestationTeeT.length !== 0) {
      obj.attestationTeeT = base64FromBytes(message.attestationTeeT);
    }
    return obj;
  },

  create(base?: DeepPartial<VerificationBundlePB>): VerificationBundlePB {
    return VerificationBundlePB.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VerificationBundlePB>): VerificationBundlePB {
    const message = createBaseVerificationBundlePB();
    message.handshakeKeys = (object.handshakeKeys !== undefined && object.handshakeKeys !== null)
      ? HandshakeSecrets.fromPartial(object.handshakeKeys)
      : undefined;
    message.teekSigned = (object.teekSigned !== undefined && object.teekSigned !== null)
      ? SignedMessage.fromPartial(object.teekSigned)
      : undefined;
    message.teetSigned = (object.teetSigned !== undefined && object.teetSigned !== null)
      ? SignedMessage.fromPartial(object.teetSigned)
      : undefined;
    message.opening = (object.opening !== undefined && object.opening !== null)
      ? Opening.fromPartial(object.opening)
      : undefined;
    message.attestationTeeK = object.attestationTeeK ?? new Uint8Array(0);
    message.attestationTeeT = object.attestationTeeT ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
