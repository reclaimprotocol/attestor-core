// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.5.0
//   protoc               v4.25.1
// source: api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "reclaim_attestor";

export enum TranscriptMessageSenderType {
  TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN = 0,
  TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT = 1,
  TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER = 2,
  UNRECOGNIZED = -1,
}

export function transcriptMessageSenderTypeFromJSON(object: any): TranscriptMessageSenderType {
  switch (object) {
    case 0:
    case "TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN":
      return TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN;
    case 1:
    case "TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT":
      return TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT;
    case 2:
    case "TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER":
      return TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TranscriptMessageSenderType.UNRECOGNIZED;
  }
}

export function transcriptMessageSenderTypeToJSON(object: TranscriptMessageSenderType): string {
  switch (object) {
    case TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN:
      return "TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN";
    case TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT:
      return "TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT";
    case TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER:
      return "TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER";
    case TranscriptMessageSenderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ServiceSignatureType {
  SERVICE_SIGNATURE_TYPE_UNKNOWN = 0,
  /**
   * SERVICE_SIGNATURE_TYPE_ETH - ETH keys & signature
   * keys: secp256k1
   * signature: ethereum flavor of ECDSA (https://goethereumbook.org/signature-generate/)
   */
  SERVICE_SIGNATURE_TYPE_ETH = 1,
  UNRECOGNIZED = -1,
}

export function serviceSignatureTypeFromJSON(object: any): ServiceSignatureType {
  switch (object) {
    case 0:
    case "SERVICE_SIGNATURE_TYPE_UNKNOWN":
      return ServiceSignatureType.SERVICE_SIGNATURE_TYPE_UNKNOWN;
    case 1:
    case "SERVICE_SIGNATURE_TYPE_ETH":
      return ServiceSignatureType.SERVICE_SIGNATURE_TYPE_ETH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceSignatureType.UNRECOGNIZED;
  }
}

export function serviceSignatureTypeToJSON(object: ServiceSignatureType): string {
  switch (object) {
    case ServiceSignatureType.SERVICE_SIGNATURE_TYPE_UNKNOWN:
      return "SERVICE_SIGNATURE_TYPE_UNKNOWN";
    case ServiceSignatureType.SERVICE_SIGNATURE_TYPE_ETH:
      return "SERVICE_SIGNATURE_TYPE_ETH";
    case ServiceSignatureType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AttestorVersion {
  ATTESTOR_VERSION_UNKNOWN = 0,
  ATTESTOR_VERSION_1_0_0 = 1,
  ATTESTOR_VERSION_1_1_0 = 2,
  ATTESTOR_VERSION_2_0_0 = 3,
  ATTESTOR_VERSION_2_0_1 = 4,
  UNRECOGNIZED = -1,
}

export function attestorVersionFromJSON(object: any): AttestorVersion {
  switch (object) {
    case 0:
    case "ATTESTOR_VERSION_UNKNOWN":
      return AttestorVersion.ATTESTOR_VERSION_UNKNOWN;
    case 1:
    case "ATTESTOR_VERSION_1_0_0":
      return AttestorVersion.ATTESTOR_VERSION_1_0_0;
    case 2:
    case "ATTESTOR_VERSION_1_1_0":
      return AttestorVersion.ATTESTOR_VERSION_1_1_0;
    case 3:
    case "ATTESTOR_VERSION_2_0_0":
      return AttestorVersion.ATTESTOR_VERSION_2_0_0;
    case 4:
    case "ATTESTOR_VERSION_2_0_1":
      return AttestorVersion.ATTESTOR_VERSION_2_0_1;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AttestorVersion.UNRECOGNIZED;
  }
}

export function attestorVersionToJSON(object: AttestorVersion): string {
  switch (object) {
    case AttestorVersion.ATTESTOR_VERSION_UNKNOWN:
      return "ATTESTOR_VERSION_UNKNOWN";
    case AttestorVersion.ATTESTOR_VERSION_1_0_0:
      return "ATTESTOR_VERSION_1_0_0";
    case AttestorVersion.ATTESTOR_VERSION_1_1_0:
      return "ATTESTOR_VERSION_1_1_0";
    case AttestorVersion.ATTESTOR_VERSION_2_0_0:
      return "ATTESTOR_VERSION_2_0_0";
    case AttestorVersion.ATTESTOR_VERSION_2_0_1:
      return "ATTESTOR_VERSION_2_0_1";
    case AttestorVersion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ErrorCode {
  /**
   * ERROR_NO_ERROR - 0 should be treated as the absence of an error
   * should be used when gracefully closing the connection
   */
  ERROR_NO_ERROR = 0,
  /**
   * ERROR_INTERNAL - internal error in the attestor -- all "Error/TypeError"
   * messages are mapped to this
   */
  ERROR_INTERNAL = 1,
  /** ERROR_BAD_REQUEST - bad request from the client */
  ERROR_BAD_REQUEST = 2,
  /** ERROR_NOT_FOUND - the item requested was not found */
  ERROR_NOT_FOUND = 3,
  /** ERROR_PROXY_ERROR - error in the proxy */
  ERROR_PROXY_ERROR = 4,
  /**
   * ERROR_INVALID_CLAIM - claim creation failed -- i.e. the transcript
   * did not result in a valid claim
   */
  ERROR_INVALID_CLAIM = 5,
  /** ERROR_NETWORK_ERROR - any network error */
  ERROR_NETWORK_ERROR = 6,
  /** ERROR_PAYMENT_REFUSED - attestor refused to pay the costs */
  ERROR_PAYMENT_REFUSED = 7,
  /**
   * ERROR_BGP_ANNOUNCEMENT_OVERLAP - BGP announcement overlapped, potentially
   * compromising the claim's authenticity
   */
  ERROR_BGP_ANNOUNCEMENT_OVERLAP = 8,
  /** ERROR_AUTHENTICATION_FAILED - authentication failed */
  ERROR_AUTHENTICATION_FAILED = 9,
  UNRECOGNIZED = -1,
}

export function errorCodeFromJSON(object: any): ErrorCode {
  switch (object) {
    case 0:
    case "ERROR_NO_ERROR":
      return ErrorCode.ERROR_NO_ERROR;
    case 1:
    case "ERROR_INTERNAL":
      return ErrorCode.ERROR_INTERNAL;
    case 2:
    case "ERROR_BAD_REQUEST":
      return ErrorCode.ERROR_BAD_REQUEST;
    case 3:
    case "ERROR_NOT_FOUND":
      return ErrorCode.ERROR_NOT_FOUND;
    case 4:
    case "ERROR_PROXY_ERROR":
      return ErrorCode.ERROR_PROXY_ERROR;
    case 5:
    case "ERROR_INVALID_CLAIM":
      return ErrorCode.ERROR_INVALID_CLAIM;
    case 6:
    case "ERROR_NETWORK_ERROR":
      return ErrorCode.ERROR_NETWORK_ERROR;
    case 7:
    case "ERROR_PAYMENT_REFUSED":
      return ErrorCode.ERROR_PAYMENT_REFUSED;
    case 8:
    case "ERROR_BGP_ANNOUNCEMENT_OVERLAP":
      return ErrorCode.ERROR_BGP_ANNOUNCEMENT_OVERLAP;
    case 9:
    case "ERROR_AUTHENTICATION_FAILED":
      return ErrorCode.ERROR_AUTHENTICATION_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorCode.UNRECOGNIZED;
  }
}

export function errorCodeToJSON(object: ErrorCode): string {
  switch (object) {
    case ErrorCode.ERROR_NO_ERROR:
      return "ERROR_NO_ERROR";
    case ErrorCode.ERROR_INTERNAL:
      return "ERROR_INTERNAL";
    case ErrorCode.ERROR_BAD_REQUEST:
      return "ERROR_BAD_REQUEST";
    case ErrorCode.ERROR_NOT_FOUND:
      return "ERROR_NOT_FOUND";
    case ErrorCode.ERROR_PROXY_ERROR:
      return "ERROR_PROXY_ERROR";
    case ErrorCode.ERROR_INVALID_CLAIM:
      return "ERROR_INVALID_CLAIM";
    case ErrorCode.ERROR_NETWORK_ERROR:
      return "ERROR_NETWORK_ERROR";
    case ErrorCode.ERROR_PAYMENT_REFUSED:
      return "ERROR_PAYMENT_REFUSED";
    case ErrorCode.ERROR_BGP_ANNOUNCEMENT_OVERLAP:
      return "ERROR_BGP_ANNOUNCEMENT_OVERLAP";
    case ErrorCode.ERROR_AUTHENTICATION_FAILED:
      return "ERROR_AUTHENTICATION_FAILED";
    case ErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ZKProofEngine {
  ZK_ENGINE_SNARKJS = 0,
  ZK_ENGINE_GNARK = 1,
  UNRECOGNIZED = -1,
}

export function zKProofEngineFromJSON(object: any): ZKProofEngine {
  switch (object) {
    case 0:
    case "ZK_ENGINE_SNARKJS":
      return ZKProofEngine.ZK_ENGINE_SNARKJS;
    case 1:
    case "ZK_ENGINE_GNARK":
      return ZKProofEngine.ZK_ENGINE_GNARK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ZKProofEngine.UNRECOGNIZED;
  }
}

export function zKProofEngineToJSON(object: ZKProofEngine): string {
  switch (object) {
    case ZKProofEngine.ZK_ENGINE_SNARKJS:
      return "ZK_ENGINE_SNARKJS";
    case ZKProofEngine.ZK_ENGINE_GNARK:
      return "ZK_ENGINE_GNARK";
    case ZKProofEngine.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ClaimContext {
  /**
   * Extracted parameters from the TLS transcript
   * by the provider. Any parameters provided by the
   * user will be overwritten
   */
  extractedParameters: { [key: string]: string };
  /** Provider hash. TODO: docs */
  providerHash: string;
}

export interface ClaimContext_ExtractedParametersEntry {
  key: string;
  value: string;
}

export interface ProviderClaimData {
  /**
   * Name of the provider to generate the
   * claim using.
   * @example "http"
   */
  provider: string;
  /**
   * Canonically JSON stringified parameters
   * of the claim, as specified by the provider.
   * @example '{"url":"https://example.com","method":"GET"}'
   */
  parameters: string;
  /**
   * Owner of the claim. Must be the public key/address
   * @example "0x1234..."
   */
  owner: string;
  /**
   * Unix timestamp in seconds of the claim being made.
   * Cannot be more than 10 minutes in the past or future
   */
  timestampS: number;
  /**
   * Any additional data you want to store with the claim.
   * Also expected to be a canonical JSON string.
   */
  context: string;
  /**
   * identifier of the claim;
   * Hash of (provider, parameters, context)
   */
  identifier: string;
  /** Legacy V1 Beacon epoch number */
  epoch: number;
}

export interface ProviderClaimInfo {
  provider: string;
  parameters: string;
  context: string;
}

export interface ErrorData {
  code: ErrorCode;
  message: string;
  data: string;
}

export interface CreateTunnelRequest {
  /**
   * Assign a unique ID to the client for this tunnel
   * request. This ID will be used to identify the tunnel
   * to later send messages or disconnect the tunnel.
   */
  id: number;
  host: string;
  port: number;
  /**
   * Geo location from which the request will be made.
   * Provide 2 letter ISO country code. Leave empty
   * if you don't want to use geo location.
   *
   * Geo location is implemented using an https proxy
   * eg. US, IN, GB, etc.
   */
  geoLocation: string;
}

export interface DisconnectTunnelRequest {
  id: number;
}

/** empty message */
export interface Empty {
}

export interface TunnelMessage {
  /** ID of the tunnel where this message belongs */
  tunnelId: number;
  message: Uint8Array;
}

export interface TunnelDisconnectEvent {
  tunnelId: number;
  error: ErrorData | undefined;
}

export interface MessageReveal {
  /**
   * direct reveal of the block via the key & IV
   * cipher (aes, chacha) for decryption
   * selected based on `cipherSuite`
   * determined by the server hello packet
   */
  directReveal?:
    | MessageReveal_MessageRevealDirect
    | undefined;
  /** partially or fully reveal the block via a zk proof */
  zkReveal?: MessageReveal_MessageRevealZk | undefined;
}

export interface MessageReveal_MessageRevealDirect {
  /** key for the block */
  key: Uint8Array;
  /** IV for the block */
  iv: Uint8Array;
  /**
   * used to generate IV in authenticated
   * cipher suites
   */
  recordNumber: number;
}

export interface MessageReveal_MessageRevealZk {
  proofs: MessageReveal_ZKProof[];
}

export interface MessageReveal_ZKProof {
  /**
   * JSON encoded snarkJS proof
   * @deprecated -- use `proofData` instead
   */
  proofJson: string;
  /** the decrypted ciphertext as output by the ZK proof */
  decryptedRedactedCiphertext: Uint8Array;
  /** the plaintext that is fully or partially revealed */
  redactedPlaintext: Uint8Array;
  /**
   * start of this specific block
   * in the redactedPlaintext
   */
  startIdx: number;
  proofData: Uint8Array;
  /**
   * If this block's proof contains an OPRF'd piece of data,
   * then provide the OPRF data here
   */
  toprf: TOPRFPayload | undefined;
}

export interface TOPRFPayload {
  /** Location of the data in the chunk that was masked */
  dataLocation:
    | DataSlice
    | undefined;
  /** OPRF hash of the data */
  nullifier: Uint8Array;
  responses: TOPRFResponse[];
}

export interface DataSlice {
  fromIndex: number;
  length: number;
}

export interface ClaimRequestData {
  provider: string;
  parameters: string;
  /**
   * Owner of the claim. Must be the public key/address
   * of the signatures
   */
  owner: string;
  /**
   * Timestamp of the claim being made.
   * Cannot be more than 10 minutes in the past
   * or in the future
   */
  timestampS: number;
  context: string;
}

export interface ClaimTunnelRequest {
  /**
   * parameters supplied to establish the tunnel
   * & connect to the end server
   */
  request:
    | CreateTunnelRequest
    | undefined;
  /** data describing the claim you want to prove */
  data:
    | ClaimRequestData
    | undefined;
  /**
   * messages from the client & server
   * in the order they were sent/received
   *
   * Attach a proof (if any) to each message
   * to reveal the contents of the message inside
   *
   * The revealed messages should support the proving
   * of the claim as defined in the provider's implementation
   */
  transcript: ClaimTunnelRequest_TranscriptMessage[];
  signatures:
    | ClaimTunnelRequest_Signatures
    | undefined;
  /** type of ZK engine used. SnarkJS or Gnark */
  zkEngine: ZKProofEngine;
  /** server and client fixed IVs needed for ZK validation */
  fixedServerIV: Uint8Array;
  fixedClientIV: Uint8Array;
}

export interface ClaimTunnelRequest_Signatures {
  /**
   * signature of ClaimTunnelRequest
   * with empty "signatures" field
   */
  requestSignature: Uint8Array;
}

export interface ClaimTunnelRequest_TranscriptMessage {
  /** client or server */
  sender: TranscriptMessageSenderType;
  /** packet data */
  message: Uint8Array;
  reveal: MessageReveal | undefined;
}

export interface ClaimTunnelResponse {
  /** The original request that was made to claim the tunnel */
  request: ClaimTunnelRequest | undefined;
  claim?: ProviderClaimData | undefined;
  error?: ErrorData | undefined;
  signatures: ClaimTunnelResponse_Signatures | undefined;
}

export interface ClaimTunnelResponse_Signatures {
  /** Address of the attestor that has signed the claim */
  attestorAddress: string;
  /**
   * signature of `stringifyProviderClaimData(claim)`,
   * if the claim was successful
   */
  claimSignature: Uint8Array;
  /**
   * signature of the complete ClaimTunnelResponse
   * structure with empty "signatures" field
   */
  resultSignature: Uint8Array;
}

export interface RequestClaimOnAvsRequest {
  /**
   * Chain ID of the chain on which the claim is to be made
   * @example 17000 (holesky)
   */
  chainId: number;
  /** Serialised JSON string of the ClaimRequest struct */
  jsonCreateClaimRequest: string;
  /** ETH signature of the `ClaimRequest` struct */
  requestSignature: Uint8Array;
}

export interface RequestClaimOnAvsResponse {
  txHash: string;
  taskIndex: number;
  jsonTask: string;
}

export interface CompleteClaimOnAvsRequest {
  /**
   * Chain ID of the chain on which the claim is to be made
   * @example 17000 (holesky)
   */
  chainId: number;
  taskIndex: number;
  completedTaskJson: string;
}

export interface CompleteClaimOnAvsResponse {
  txHash: string;
  taskCompletedObjectJson: string;
}

export interface CreateTaskOnMechainRequest {
  timestamp: number;
}

export interface CreateTaskOnMechainResponse {
  taskId: number;
  requiredAttestors: number;
  hosts: string[];
}

export interface AuthenticatedUserData {
  /** Unique identifier for the user */
  id: string;
  createdAt: number;
  /**
   * Unix timestamp in seconds when the user's
   * authentication will expire.
   */
  expiresAt: number;
  /**
   * List of allowed hosts the user is allowed to connect to.
   * Will throw a BAD_REQUEST error if the user tries to connect.
   * Pass an empty list to allow all hosts.
   */
  hostWhitelist: string[];
}

export interface AuthenticationRequest {
  data:
    | AuthenticatedUserData
    | undefined;
  /** Signature of the `userData` */
  signature: Uint8Array;
}

export interface InitRequest {
  /** Attestor client version */
  clientVersion: AttestorVersion;
  /** Signature type used & expected by the user */
  signatureType: ServiceSignatureType;
  /**
   * Request the attestor to authenticate the user
   * with the given data. If auth fails, will return
   * an AUTHENTICATION_FAILED error.
   */
  auth: AuthenticationRequest | undefined;
}

export interface InitResponse {
  toprfPublicKey: Uint8Array;
}

export interface TOPRFRequest {
  maskedData: Uint8Array;
  engine: ZKProofEngine;
}

export interface TOPRFResponse {
  publicKeyShare: Uint8Array;
  /** OPRF output */
  evaluated: Uint8Array;
  c: Uint8Array;
  r: Uint8Array;
}

export interface RPCMessage {
  /**
   * Per connection unique RPC message ID. Either party sending a
   * duplicate ID will do nothing except confuse the other party.
   *
   * For response messages, the ID should be the same as the request
   * to which it is responding.
   */
  id: number;
  initRequest?:
    | InitRequest
    | undefined;
  /** Response to the init request. */
  initResponse?:
    | InitResponse
    | undefined;
  /**
   * Data representing an error in the WebSocket connection.
   * The party sending this message should close the connection
   * immediately after sending this message.
   */
  connectionTerminationAlert?:
    | ErrorData
    | undefined;
  /**
   * Data representing an error in the attestor's
   * request to the server. This should be sent in case
   * there was an error in processing the request.
   */
  requestError?:
    | ErrorData
    | undefined;
  /** Create a tunnel to the specified host & port. */
  createTunnelRequest?: CreateTunnelRequest | undefined;
  createTunnelResponse?:
    | Empty
    | undefined;
  /** Disconnect a tunnel. */
  disconnectTunnelRequest?: DisconnectTunnelRequest | undefined;
  disconnectTunnelResponse?:
    | Empty
    | undefined;
  /**
   * Message to send through a tunnel. Client can send
   * this message to forward data to the server.
   */
  tunnelMessage?:
    | TunnelMessage
    | undefined;
  /**
   * Event indicating that a tunnel has been disconnected.
   * The client should not send any more messages through
   * this tunnel.
   */
  tunnelDisconnectEvent?:
    | TunnelDisconnectEvent
    | undefined;
  /**
   * Using the transcript of a tunnel, make a claim.
   * The tunnel must be disconnected before making a claim.
   */
  claimTunnelRequest?: ClaimTunnelRequest | undefined;
  claimTunnelResponse?:
    | ClaimTunnelResponse
    | undefined;
  /**
   * Request the attestor to pay for the claim on the chain.
   * The Attestor can choose to reject the request.
   */
  createClaimOnChainRequest?: RequestClaimOnAvsRequest | undefined;
  createClaimOnChainResponse?:
    | RequestClaimOnAvsResponse
    | undefined;
  /** Submit the work done for the claim on the chain. */
  completeClaimOnChainRequest?: CompleteClaimOnAvsRequest | undefined;
  completeClaimOnChainResponse?:
    | CompleteClaimOnAvsResponse
    | undefined;
  /** Request to perform thresholded OPRF */
  toprfRequest?: TOPRFRequest | undefined;
  toprfResponse?:
    | TOPRFResponse
    | undefined;
  /** Request the attestor to create a Task on the ReclaimTask contract. */
  createTaskOnMechainRequest?: CreateTaskOnMechainRequest | undefined;
  createTaskOnMechainResponse?: CreateTaskOnMechainResponse | undefined;
}

export interface RPCMessages {
  messages: RPCMessage[];
}

function createBaseClaimContext(): ClaimContext {
  return { extractedParameters: {}, providerHash: "" };
}

export const ClaimContext: MessageFns<ClaimContext> = {
  encode(message: ClaimContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.extractedParameters).forEach(([key, value]) => {
      ClaimContext_ExtractedParametersEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.providerHash !== "") {
      writer.uint32(18).string(message.providerHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = ClaimContext_ExtractedParametersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.extractedParameters[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimContext {
    return {
      extractedParameters: isObject(object.extractedParameters)
        ? Object.entries(object.extractedParameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      providerHash: isSet(object.providerHash) ? globalThis.String(object.providerHash) : "",
    };
  },

  toJSON(message: ClaimContext): unknown {
    const obj: any = {};
    if (message.extractedParameters) {
      const entries = Object.entries(message.extractedParameters);
      if (entries.length > 0) {
        obj.extractedParameters = {};
        entries.forEach(([k, v]) => {
          obj.extractedParameters[k] = v;
        });
      }
    }
    if (message.providerHash !== "") {
      obj.providerHash = message.providerHash;
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimContext>): ClaimContext {
    return ClaimContext.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimContext>): ClaimContext {
    const message = createBaseClaimContext();
    message.extractedParameters = Object.entries(object.extractedParameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.providerHash = object.providerHash ?? "";
    return message;
  },
};

function createBaseClaimContext_ExtractedParametersEntry(): ClaimContext_ExtractedParametersEntry {
  return { key: "", value: "" };
}

export const ClaimContext_ExtractedParametersEntry: MessageFns<ClaimContext_ExtractedParametersEntry> = {
  encode(message: ClaimContext_ExtractedParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimContext_ExtractedParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimContext_ExtractedParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimContext_ExtractedParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ClaimContext_ExtractedParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimContext_ExtractedParametersEntry>): ClaimContext_ExtractedParametersEntry {
    return ClaimContext_ExtractedParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimContext_ExtractedParametersEntry>): ClaimContext_ExtractedParametersEntry {
    const message = createBaseClaimContext_ExtractedParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseProviderClaimData(): ProviderClaimData {
  return { provider: "", parameters: "", owner: "", timestampS: 0, context: "", identifier: "", epoch: 0 };
}

export const ProviderClaimData: MessageFns<ProviderClaimData> = {
  encode(message: ProviderClaimData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.parameters !== "") {
      writer.uint32(18).string(message.parameters);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.timestampS !== 0) {
      writer.uint32(32).uint32(message.timestampS);
    }
    if (message.context !== "") {
      writer.uint32(50).string(message.context);
    }
    if (message.identifier !== "") {
      writer.uint32(66).string(message.identifier);
    }
    if (message.epoch !== 0) {
      writer.uint32(72).uint32(message.epoch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderClaimData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderClaimData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parameters = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestampS = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.epoch = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderClaimData {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      timestampS: isSet(object.timestampS) ? globalThis.Number(object.timestampS) : 0,
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      epoch: isSet(object.epoch) ? globalThis.Number(object.epoch) : 0,
    };
  },

  toJSON(message: ProviderClaimData): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.parameters !== "") {
      obj.parameters = message.parameters;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.timestampS !== 0) {
      obj.timestampS = Math.round(message.timestampS);
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.epoch !== 0) {
      obj.epoch = Math.round(message.epoch);
    }
    return obj;
  },

  create(base?: DeepPartial<ProviderClaimData>): ProviderClaimData {
    return ProviderClaimData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProviderClaimData>): ProviderClaimData {
    const message = createBaseProviderClaimData();
    message.provider = object.provider ?? "";
    message.parameters = object.parameters ?? "";
    message.owner = object.owner ?? "";
    message.timestampS = object.timestampS ?? 0;
    message.context = object.context ?? "";
    message.identifier = object.identifier ?? "";
    message.epoch = object.epoch ?? 0;
    return message;
  },
};

function createBaseProviderClaimInfo(): ProviderClaimInfo {
  return { provider: "", parameters: "", context: "" };
}

export const ProviderClaimInfo: MessageFns<ProviderClaimInfo> = {
  encode(message: ProviderClaimInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.parameters !== "") {
      writer.uint32(18).string(message.parameters);
    }
    if (message.context !== "") {
      writer.uint32(50).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderClaimInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderClaimInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parameters = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.context = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderClaimInfo {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: ProviderClaimInfo): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.parameters !== "") {
      obj.parameters = message.parameters;
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    return obj;
  },

  create(base?: DeepPartial<ProviderClaimInfo>): ProviderClaimInfo {
    return ProviderClaimInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProviderClaimInfo>): ProviderClaimInfo {
    const message = createBaseProviderClaimInfo();
    message.provider = object.provider ?? "";
    message.parameters = object.parameters ?? "";
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseErrorData(): ErrorData {
  return { code: 0, message: "", data: "" };
}

export const ErrorData: MessageFns<ErrorData> = {
  encode(message: ErrorData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== "") {
      writer.uint32(26).string(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorData {
    return {
      code: isSet(object.code) ? errorCodeFromJSON(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
    };
  },

  toJSON(message: ErrorData): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = errorCodeToJSON(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorData>): ErrorData {
    return ErrorData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorData>): ErrorData {
    const message = createBaseErrorData();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseCreateTunnelRequest(): CreateTunnelRequest {
  return { id: 0, host: "", port: 0, geoLocation: "" };
}

export const CreateTunnelRequest: MessageFns<CreateTunnelRequest> = {
  encode(message: CreateTunnelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(24).uint32(message.port);
    }
    if (message.geoLocation !== "") {
      writer.uint32(34).string(message.geoLocation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTunnelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTunnelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.geoLocation = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTunnelRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      geoLocation: isSet(object.geoLocation) ? globalThis.String(object.geoLocation) : "",
    };
  },

  toJSON(message: CreateTunnelRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.geoLocation !== "") {
      obj.geoLocation = message.geoLocation;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTunnelRequest>): CreateTunnelRequest {
    return CreateTunnelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTunnelRequest>): CreateTunnelRequest {
    const message = createBaseCreateTunnelRequest();
    message.id = object.id ?? 0;
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    message.geoLocation = object.geoLocation ?? "";
    return message;
  },
};

function createBaseDisconnectTunnelRequest(): DisconnectTunnelRequest {
  return { id: 0 };
}

export const DisconnectTunnelRequest: MessageFns<DisconnectTunnelRequest> = {
  encode(message: DisconnectTunnelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisconnectTunnelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisconnectTunnelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisconnectTunnelRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: DisconnectTunnelRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<DisconnectTunnelRequest>): DisconnectTunnelRequest {
    return DisconnectTunnelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DisconnectTunnelRequest>): DisconnectTunnelRequest {
    const message = createBaseDisconnectTunnelRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Empty>): Empty {
    return Empty.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Empty>): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseTunnelMessage(): TunnelMessage {
  return { tunnelId: 0, message: new Uint8Array(0) };
}

export const TunnelMessage: MessageFns<TunnelMessage> = {
  encode(message: TunnelMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tunnelId !== 0) {
      writer.uint32(8).uint32(message.tunnelId);
    }
    if (message.message.length !== 0) {
      writer.uint32(18).bytes(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TunnelMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunnelMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tunnelId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunnelMessage {
    return {
      tunnelId: isSet(object.tunnelId) ? globalThis.Number(object.tunnelId) : 0,
      message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
    };
  },

  toJSON(message: TunnelMessage): unknown {
    const obj: any = {};
    if (message.tunnelId !== 0) {
      obj.tunnelId = Math.round(message.tunnelId);
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<TunnelMessage>): TunnelMessage {
    return TunnelMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunnelMessage>): TunnelMessage {
    const message = createBaseTunnelMessage();
    message.tunnelId = object.tunnelId ?? 0;
    message.message = object.message ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTunnelDisconnectEvent(): TunnelDisconnectEvent {
  return { tunnelId: 0, error: undefined };
}

export const TunnelDisconnectEvent: MessageFns<TunnelDisconnectEvent> = {
  encode(message: TunnelDisconnectEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tunnelId !== 0) {
      writer.uint32(8).uint32(message.tunnelId);
    }
    if (message.error !== undefined) {
      ErrorData.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TunnelDisconnectEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunnelDisconnectEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tunnelId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = ErrorData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunnelDisconnectEvent {
    return {
      tunnelId: isSet(object.tunnelId) ? globalThis.Number(object.tunnelId) : 0,
      error: isSet(object.error) ? ErrorData.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: TunnelDisconnectEvent): unknown {
    const obj: any = {};
    if (message.tunnelId !== 0) {
      obj.tunnelId = Math.round(message.tunnelId);
    }
    if (message.error !== undefined) {
      obj.error = ErrorData.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<TunnelDisconnectEvent>): TunnelDisconnectEvent {
    return TunnelDisconnectEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunnelDisconnectEvent>): TunnelDisconnectEvent {
    const message = createBaseTunnelDisconnectEvent();
    message.tunnelId = object.tunnelId ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? ErrorData.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseMessageReveal(): MessageReveal {
  return { directReveal: undefined, zkReveal: undefined };
}

export const MessageReveal: MessageFns<MessageReveal> = {
  encode(message: MessageReveal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.directReveal !== undefined) {
      MessageReveal_MessageRevealDirect.encode(message.directReveal, writer.uint32(10).fork()).join();
    }
    if (message.zkReveal !== undefined) {
      MessageReveal_MessageRevealZk.encode(message.zkReveal, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageReveal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReveal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.directReveal = MessageReveal_MessageRevealDirect.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.zkReveal = MessageReveal_MessageRevealZk.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReveal {
    return {
      directReveal: isSet(object.directReveal)
        ? MessageReveal_MessageRevealDirect.fromJSON(object.directReveal)
        : undefined,
      zkReveal: isSet(object.zkReveal) ? MessageReveal_MessageRevealZk.fromJSON(object.zkReveal) : undefined,
    };
  },

  toJSON(message: MessageReveal): unknown {
    const obj: any = {};
    if (message.directReveal !== undefined) {
      obj.directReveal = MessageReveal_MessageRevealDirect.toJSON(message.directReveal);
    }
    if (message.zkReveal !== undefined) {
      obj.zkReveal = MessageReveal_MessageRevealZk.toJSON(message.zkReveal);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageReveal>): MessageReveal {
    return MessageReveal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageReveal>): MessageReveal {
    const message = createBaseMessageReveal();
    message.directReveal = (object.directReveal !== undefined && object.directReveal !== null)
      ? MessageReveal_MessageRevealDirect.fromPartial(object.directReveal)
      : undefined;
    message.zkReveal = (object.zkReveal !== undefined && object.zkReveal !== null)
      ? MessageReveal_MessageRevealZk.fromPartial(object.zkReveal)
      : undefined;
    return message;
  },
};

function createBaseMessageReveal_MessageRevealDirect(): MessageReveal_MessageRevealDirect {
  return { key: new Uint8Array(0), iv: new Uint8Array(0), recordNumber: 0 };
}

export const MessageReveal_MessageRevealDirect: MessageFns<MessageReveal_MessageRevealDirect> = {
  encode(message: MessageReveal_MessageRevealDirect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.iv.length !== 0) {
      writer.uint32(18).bytes(message.iv);
    }
    if (message.recordNumber !== 0) {
      writer.uint32(24).uint32(message.recordNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageReveal_MessageRevealDirect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReveal_MessageRevealDirect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.iv = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.recordNumber = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReveal_MessageRevealDirect {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      iv: isSet(object.iv) ? bytesFromBase64(object.iv) : new Uint8Array(0),
      recordNumber: isSet(object.recordNumber) ? globalThis.Number(object.recordNumber) : 0,
    };
  },

  toJSON(message: MessageReveal_MessageRevealDirect): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.iv.length !== 0) {
      obj.iv = base64FromBytes(message.iv);
    }
    if (message.recordNumber !== 0) {
      obj.recordNumber = Math.round(message.recordNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageReveal_MessageRevealDirect>): MessageReveal_MessageRevealDirect {
    return MessageReveal_MessageRevealDirect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageReveal_MessageRevealDirect>): MessageReveal_MessageRevealDirect {
    const message = createBaseMessageReveal_MessageRevealDirect();
    message.key = object.key ?? new Uint8Array(0);
    message.iv = object.iv ?? new Uint8Array(0);
    message.recordNumber = object.recordNumber ?? 0;
    return message;
  },
};

function createBaseMessageReveal_MessageRevealZk(): MessageReveal_MessageRevealZk {
  return { proofs: [] };
}

export const MessageReveal_MessageRevealZk: MessageFns<MessageReveal_MessageRevealZk> = {
  encode(message: MessageReveal_MessageRevealZk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.proofs) {
      MessageReveal_ZKProof.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageReveal_MessageRevealZk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReveal_MessageRevealZk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofs.push(MessageReveal_ZKProof.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReveal_MessageRevealZk {
    return {
      proofs: globalThis.Array.isArray(object?.proofs)
        ? object.proofs.map((e: any) => MessageReveal_ZKProof.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MessageReveal_MessageRevealZk): unknown {
    const obj: any = {};
    if (message.proofs?.length) {
      obj.proofs = message.proofs.map((e) => MessageReveal_ZKProof.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MessageReveal_MessageRevealZk>): MessageReveal_MessageRevealZk {
    return MessageReveal_MessageRevealZk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageReveal_MessageRevealZk>): MessageReveal_MessageRevealZk {
    const message = createBaseMessageReveal_MessageRevealZk();
    message.proofs = object.proofs?.map((e) => MessageReveal_ZKProof.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessageReveal_ZKProof(): MessageReveal_ZKProof {
  return {
    proofJson: "",
    decryptedRedactedCiphertext: new Uint8Array(0),
    redactedPlaintext: new Uint8Array(0),
    startIdx: 0,
    proofData: new Uint8Array(0),
    toprf: undefined,
  };
}

export const MessageReveal_ZKProof: MessageFns<MessageReveal_ZKProof> = {
  encode(message: MessageReveal_ZKProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proofJson !== "") {
      writer.uint32(10).string(message.proofJson);
    }
    if (message.decryptedRedactedCiphertext.length !== 0) {
      writer.uint32(18).bytes(message.decryptedRedactedCiphertext);
    }
    if (message.redactedPlaintext.length !== 0) {
      writer.uint32(26).bytes(message.redactedPlaintext);
    }
    if (message.startIdx !== 0) {
      writer.uint32(32).uint32(message.startIdx);
    }
    if (message.proofData.length !== 0) {
      writer.uint32(42).bytes(message.proofData);
    }
    if (message.toprf !== undefined) {
      TOPRFPayload.encode(message.toprf, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageReveal_ZKProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReveal_ZKProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofJson = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.decryptedRedactedCiphertext = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.redactedPlaintext = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.startIdx = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.proofData = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toprf = TOPRFPayload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReveal_ZKProof {
    return {
      proofJson: isSet(object.proofJson) ? globalThis.String(object.proofJson) : "",
      decryptedRedactedCiphertext: isSet(object.decryptedRedactedCiphertext)
        ? bytesFromBase64(object.decryptedRedactedCiphertext)
        : new Uint8Array(0),
      redactedPlaintext: isSet(object.redactedPlaintext)
        ? bytesFromBase64(object.redactedPlaintext)
        : new Uint8Array(0),
      startIdx: isSet(object.startIdx) ? globalThis.Number(object.startIdx) : 0,
      proofData: isSet(object.proofData) ? bytesFromBase64(object.proofData) : new Uint8Array(0),
      toprf: isSet(object.toprf) ? TOPRFPayload.fromJSON(object.toprf) : undefined,
    };
  },

  toJSON(message: MessageReveal_ZKProof): unknown {
    const obj: any = {};
    if (message.proofJson !== "") {
      obj.proofJson = message.proofJson;
    }
    if (message.decryptedRedactedCiphertext.length !== 0) {
      obj.decryptedRedactedCiphertext = base64FromBytes(message.decryptedRedactedCiphertext);
    }
    if (message.redactedPlaintext.length !== 0) {
      obj.redactedPlaintext = base64FromBytes(message.redactedPlaintext);
    }
    if (message.startIdx !== 0) {
      obj.startIdx = Math.round(message.startIdx);
    }
    if (message.proofData.length !== 0) {
      obj.proofData = base64FromBytes(message.proofData);
    }
    if (message.toprf !== undefined) {
      obj.toprf = TOPRFPayload.toJSON(message.toprf);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageReveal_ZKProof>): MessageReveal_ZKProof {
    return MessageReveal_ZKProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageReveal_ZKProof>): MessageReveal_ZKProof {
    const message = createBaseMessageReveal_ZKProof();
    message.proofJson = object.proofJson ?? "";
    message.decryptedRedactedCiphertext = object.decryptedRedactedCiphertext ?? new Uint8Array(0);
    message.redactedPlaintext = object.redactedPlaintext ?? new Uint8Array(0);
    message.startIdx = object.startIdx ?? 0;
    message.proofData = object.proofData ?? new Uint8Array(0);
    message.toprf = (object.toprf !== undefined && object.toprf !== null)
      ? TOPRFPayload.fromPartial(object.toprf)
      : undefined;
    return message;
  },
};

function createBaseTOPRFPayload(): TOPRFPayload {
  return { dataLocation: undefined, nullifier: new Uint8Array(0), responses: [] };
}

export const TOPRFPayload: MessageFns<TOPRFPayload> = {
  encode(message: TOPRFPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataLocation !== undefined) {
      DataSlice.encode(message.dataLocation, writer.uint32(10).fork()).join();
    }
    if (message.nullifier.length !== 0) {
      writer.uint32(18).bytes(message.nullifier);
    }
    for (const v of message.responses) {
      TOPRFResponse.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TOPRFPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTOPRFPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dataLocation = DataSlice.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nullifier = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.responses.push(TOPRFResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TOPRFPayload {
    return {
      dataLocation: isSet(object.dataLocation) ? DataSlice.fromJSON(object.dataLocation) : undefined,
      nullifier: isSet(object.nullifier) ? bytesFromBase64(object.nullifier) : new Uint8Array(0),
      responses: globalThis.Array.isArray(object?.responses)
        ? object.responses.map((e: any) => TOPRFResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TOPRFPayload): unknown {
    const obj: any = {};
    if (message.dataLocation !== undefined) {
      obj.dataLocation = DataSlice.toJSON(message.dataLocation);
    }
    if (message.nullifier.length !== 0) {
      obj.nullifier = base64FromBytes(message.nullifier);
    }
    if (message.responses?.length) {
      obj.responses = message.responses.map((e) => TOPRFResponse.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TOPRFPayload>): TOPRFPayload {
    return TOPRFPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TOPRFPayload>): TOPRFPayload {
    const message = createBaseTOPRFPayload();
    message.dataLocation = (object.dataLocation !== undefined && object.dataLocation !== null)
      ? DataSlice.fromPartial(object.dataLocation)
      : undefined;
    message.nullifier = object.nullifier ?? new Uint8Array(0);
    message.responses = object.responses?.map((e) => TOPRFResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDataSlice(): DataSlice {
  return { fromIndex: 0, length: 0 };
}

export const DataSlice: MessageFns<DataSlice> = {
  encode(message: DataSlice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromIndex !== 0) {
      writer.uint32(8).uint32(message.fromIndex);
    }
    if (message.length !== 0) {
      writer.uint32(16).uint32(message.length);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSlice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSlice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.length = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSlice {
    return {
      fromIndex: isSet(object.fromIndex) ? globalThis.Number(object.fromIndex) : 0,
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
    };
  },

  toJSON(message: DataSlice): unknown {
    const obj: any = {};
    if (message.fromIndex !== 0) {
      obj.fromIndex = Math.round(message.fromIndex);
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    return obj;
  },

  create(base?: DeepPartial<DataSlice>): DataSlice {
    return DataSlice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSlice>): DataSlice {
    const message = createBaseDataSlice();
    message.fromIndex = object.fromIndex ?? 0;
    message.length = object.length ?? 0;
    return message;
  },
};

function createBaseClaimRequestData(): ClaimRequestData {
  return { provider: "", parameters: "", owner: "", timestampS: 0, context: "" };
}

export const ClaimRequestData: MessageFns<ClaimRequestData> = {
  encode(message: ClaimRequestData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.parameters !== "") {
      writer.uint32(18).string(message.parameters);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.timestampS !== 0) {
      writer.uint32(32).uint32(message.timestampS);
    }
    if (message.context !== "") {
      writer.uint32(42).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimRequestData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimRequestData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parameters = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestampS = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.context = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimRequestData {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      timestampS: isSet(object.timestampS) ? globalThis.Number(object.timestampS) : 0,
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: ClaimRequestData): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.parameters !== "") {
      obj.parameters = message.parameters;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.timestampS !== 0) {
      obj.timestampS = Math.round(message.timestampS);
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimRequestData>): ClaimRequestData {
    return ClaimRequestData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimRequestData>): ClaimRequestData {
    const message = createBaseClaimRequestData();
    message.provider = object.provider ?? "";
    message.parameters = object.parameters ?? "";
    message.owner = object.owner ?? "";
    message.timestampS = object.timestampS ?? 0;
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseClaimTunnelRequest(): ClaimTunnelRequest {
  return {
    request: undefined,
    data: undefined,
    transcript: [],
    signatures: undefined,
    zkEngine: 0,
    fixedServerIV: new Uint8Array(0),
    fixedClientIV: new Uint8Array(0),
  };
}

export const ClaimTunnelRequest: MessageFns<ClaimTunnelRequest> = {
  encode(message: ClaimTunnelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      CreateTunnelRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      ClaimRequestData.encode(message.data, writer.uint32(18).fork()).join();
    }
    for (const v of message.transcript) {
      ClaimTunnelRequest_TranscriptMessage.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.signatures !== undefined) {
      ClaimTunnelRequest_Signatures.encode(message.signatures, writer.uint32(34).fork()).join();
    }
    if (message.zkEngine !== 0) {
      writer.uint32(40).int32(message.zkEngine);
    }
    if (message.fixedServerIV.length !== 0) {
      writer.uint32(50).bytes(message.fixedServerIV);
    }
    if (message.fixedClientIV.length !== 0) {
      writer.uint32(58).bytes(message.fixedClientIV);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimTunnelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = CreateTunnelRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = ClaimRequestData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transcript.push(ClaimTunnelRequest_TranscriptMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signatures = ClaimTunnelRequest_Signatures.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.zkEngine = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fixedServerIV = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.fixedClientIV = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelRequest {
    return {
      request: isSet(object.request) ? CreateTunnelRequest.fromJSON(object.request) : undefined,
      data: isSet(object.data) ? ClaimRequestData.fromJSON(object.data) : undefined,
      transcript: globalThis.Array.isArray(object?.transcript)
        ? object.transcript.map((e: any) => ClaimTunnelRequest_TranscriptMessage.fromJSON(e))
        : [],
      signatures: isSet(object.signatures) ? ClaimTunnelRequest_Signatures.fromJSON(object.signatures) : undefined,
      zkEngine: isSet(object.zkEngine) ? zKProofEngineFromJSON(object.zkEngine) : 0,
      fixedServerIV: isSet(object.fixedServerIV) ? bytesFromBase64(object.fixedServerIV) : new Uint8Array(0),
      fixedClientIV: isSet(object.fixedClientIV) ? bytesFromBase64(object.fixedClientIV) : new Uint8Array(0),
    };
  },

  toJSON(message: ClaimTunnelRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = CreateTunnelRequest.toJSON(message.request);
    }
    if (message.data !== undefined) {
      obj.data = ClaimRequestData.toJSON(message.data);
    }
    if (message.transcript?.length) {
      obj.transcript = message.transcript.map((e) => ClaimTunnelRequest_TranscriptMessage.toJSON(e));
    }
    if (message.signatures !== undefined) {
      obj.signatures = ClaimTunnelRequest_Signatures.toJSON(message.signatures);
    }
    if (message.zkEngine !== 0) {
      obj.zkEngine = zKProofEngineToJSON(message.zkEngine);
    }
    if (message.fixedServerIV.length !== 0) {
      obj.fixedServerIV = base64FromBytes(message.fixedServerIV);
    }
    if (message.fixedClientIV.length !== 0) {
      obj.fixedClientIV = base64FromBytes(message.fixedClientIV);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelRequest>): ClaimTunnelRequest {
    return ClaimTunnelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelRequest>): ClaimTunnelRequest {
    const message = createBaseClaimTunnelRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? CreateTunnelRequest.fromPartial(object.request)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? ClaimRequestData.fromPartial(object.data)
      : undefined;
    message.transcript = object.transcript?.map((e) => ClaimTunnelRequest_TranscriptMessage.fromPartial(e)) || [];
    message.signatures = (object.signatures !== undefined && object.signatures !== null)
      ? ClaimTunnelRequest_Signatures.fromPartial(object.signatures)
      : undefined;
    message.zkEngine = object.zkEngine ?? 0;
    message.fixedServerIV = object.fixedServerIV ?? new Uint8Array(0);
    message.fixedClientIV = object.fixedClientIV ?? new Uint8Array(0);
    return message;
  },
};

function createBaseClaimTunnelRequest_Signatures(): ClaimTunnelRequest_Signatures {
  return { requestSignature: new Uint8Array(0) };
}

export const ClaimTunnelRequest_Signatures: MessageFns<ClaimTunnelRequest_Signatures> = {
  encode(message: ClaimTunnelRequest_Signatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestSignature.length !== 0) {
      writer.uint32(10).bytes(message.requestSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimTunnelRequest_Signatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelRequest_Signatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelRequest_Signatures {
    return {
      requestSignature: isSet(object.requestSignature) ? bytesFromBase64(object.requestSignature) : new Uint8Array(0),
    };
  },

  toJSON(message: ClaimTunnelRequest_Signatures): unknown {
    const obj: any = {};
    if (message.requestSignature.length !== 0) {
      obj.requestSignature = base64FromBytes(message.requestSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelRequest_Signatures>): ClaimTunnelRequest_Signatures {
    return ClaimTunnelRequest_Signatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelRequest_Signatures>): ClaimTunnelRequest_Signatures {
    const message = createBaseClaimTunnelRequest_Signatures();
    message.requestSignature = object.requestSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseClaimTunnelRequest_TranscriptMessage(): ClaimTunnelRequest_TranscriptMessage {
  return { sender: 0, message: new Uint8Array(0), reveal: undefined };
}

export const ClaimTunnelRequest_TranscriptMessage: MessageFns<ClaimTunnelRequest_TranscriptMessage> = {
  encode(message: ClaimTunnelRequest_TranscriptMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== 0) {
      writer.uint32(8).int32(message.sender);
    }
    if (message.message.length !== 0) {
      writer.uint32(18).bytes(message.message);
    }
    if (message.reveal !== undefined) {
      MessageReveal.encode(message.reveal, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimTunnelRequest_TranscriptMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelRequest_TranscriptMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sender = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reveal = MessageReveal.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelRequest_TranscriptMessage {
    return {
      sender: isSet(object.sender) ? transcriptMessageSenderTypeFromJSON(object.sender) : 0,
      message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
      reveal: isSet(object.reveal) ? MessageReveal.fromJSON(object.reveal) : undefined,
    };
  },

  toJSON(message: ClaimTunnelRequest_TranscriptMessage): unknown {
    const obj: any = {};
    if (message.sender !== 0) {
      obj.sender = transcriptMessageSenderTypeToJSON(message.sender);
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    if (message.reveal !== undefined) {
      obj.reveal = MessageReveal.toJSON(message.reveal);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelRequest_TranscriptMessage>): ClaimTunnelRequest_TranscriptMessage {
    return ClaimTunnelRequest_TranscriptMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelRequest_TranscriptMessage>): ClaimTunnelRequest_TranscriptMessage {
    const message = createBaseClaimTunnelRequest_TranscriptMessage();
    message.sender = object.sender ?? 0;
    message.message = object.message ?? new Uint8Array(0);
    message.reveal = (object.reveal !== undefined && object.reveal !== null)
      ? MessageReveal.fromPartial(object.reveal)
      : undefined;
    return message;
  },
};

function createBaseClaimTunnelResponse(): ClaimTunnelResponse {
  return { request: undefined, claim: undefined, error: undefined, signatures: undefined };
}

export const ClaimTunnelResponse: MessageFns<ClaimTunnelResponse> = {
  encode(message: ClaimTunnelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      ClaimTunnelRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.claim !== undefined) {
      ProviderClaimData.encode(message.claim, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      ErrorData.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.signatures !== undefined) {
      ClaimTunnelResponse_Signatures.encode(message.signatures, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimTunnelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = ClaimTunnelRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.claim = ProviderClaimData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = ErrorData.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signatures = ClaimTunnelResponse_Signatures.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelResponse {
    return {
      request: isSet(object.request) ? ClaimTunnelRequest.fromJSON(object.request) : undefined,
      claim: isSet(object.claim) ? ProviderClaimData.fromJSON(object.claim) : undefined,
      error: isSet(object.error) ? ErrorData.fromJSON(object.error) : undefined,
      signatures: isSet(object.signatures) ? ClaimTunnelResponse_Signatures.fromJSON(object.signatures) : undefined,
    };
  },

  toJSON(message: ClaimTunnelResponse): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = ClaimTunnelRequest.toJSON(message.request);
    }
    if (message.claim !== undefined) {
      obj.claim = ProviderClaimData.toJSON(message.claim);
    }
    if (message.error !== undefined) {
      obj.error = ErrorData.toJSON(message.error);
    }
    if (message.signatures !== undefined) {
      obj.signatures = ClaimTunnelResponse_Signatures.toJSON(message.signatures);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelResponse>): ClaimTunnelResponse {
    return ClaimTunnelResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelResponse>): ClaimTunnelResponse {
    const message = createBaseClaimTunnelResponse();
    message.request = (object.request !== undefined && object.request !== null)
      ? ClaimTunnelRequest.fromPartial(object.request)
      : undefined;
    message.claim = (object.claim !== undefined && object.claim !== null)
      ? ProviderClaimData.fromPartial(object.claim)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? ErrorData.fromPartial(object.error)
      : undefined;
    message.signatures = (object.signatures !== undefined && object.signatures !== null)
      ? ClaimTunnelResponse_Signatures.fromPartial(object.signatures)
      : undefined;
    return message;
  },
};

function createBaseClaimTunnelResponse_Signatures(): ClaimTunnelResponse_Signatures {
  return { attestorAddress: "", claimSignature: new Uint8Array(0), resultSignature: new Uint8Array(0) };
}

export const ClaimTunnelResponse_Signatures: MessageFns<ClaimTunnelResponse_Signatures> = {
  encode(message: ClaimTunnelResponse_Signatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attestorAddress !== "") {
      writer.uint32(10).string(message.attestorAddress);
    }
    if (message.claimSignature.length !== 0) {
      writer.uint32(18).bytes(message.claimSignature);
    }
    if (message.resultSignature.length !== 0) {
      writer.uint32(26).bytes(message.resultSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimTunnelResponse_Signatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelResponse_Signatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attestorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.claimSignature = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resultSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelResponse_Signatures {
    return {
      attestorAddress: isSet(object.attestorAddress) ? globalThis.String(object.attestorAddress) : "",
      claimSignature: isSet(object.claimSignature) ? bytesFromBase64(object.claimSignature) : new Uint8Array(0),
      resultSignature: isSet(object.resultSignature) ? bytesFromBase64(object.resultSignature) : new Uint8Array(0),
    };
  },

  toJSON(message: ClaimTunnelResponse_Signatures): unknown {
    const obj: any = {};
    if (message.attestorAddress !== "") {
      obj.attestorAddress = message.attestorAddress;
    }
    if (message.claimSignature.length !== 0) {
      obj.claimSignature = base64FromBytes(message.claimSignature);
    }
    if (message.resultSignature.length !== 0) {
      obj.resultSignature = base64FromBytes(message.resultSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelResponse_Signatures>): ClaimTunnelResponse_Signatures {
    return ClaimTunnelResponse_Signatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelResponse_Signatures>): ClaimTunnelResponse_Signatures {
    const message = createBaseClaimTunnelResponse_Signatures();
    message.attestorAddress = object.attestorAddress ?? "";
    message.claimSignature = object.claimSignature ?? new Uint8Array(0);
    message.resultSignature = object.resultSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRequestClaimOnAvsRequest(): RequestClaimOnAvsRequest {
  return { chainId: 0, jsonCreateClaimRequest: "", requestSignature: new Uint8Array(0) };
}

export const RequestClaimOnAvsRequest: MessageFns<RequestClaimOnAvsRequest> = {
  encode(message: RequestClaimOnAvsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== 0) {
      writer.uint32(8).uint32(message.chainId);
    }
    if (message.jsonCreateClaimRequest !== "") {
      writer.uint32(18).string(message.jsonCreateClaimRequest);
    }
    if (message.requestSignature.length !== 0) {
      writer.uint32(26).bytes(message.requestSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestClaimOnAvsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestClaimOnAvsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.chainId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jsonCreateClaimRequest = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requestSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestClaimOnAvsRequest {
    return {
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
      jsonCreateClaimRequest: isSet(object.jsonCreateClaimRequest)
        ? globalThis.String(object.jsonCreateClaimRequest)
        : "",
      requestSignature: isSet(object.requestSignature) ? bytesFromBase64(object.requestSignature) : new Uint8Array(0),
    };
  },

  toJSON(message: RequestClaimOnAvsRequest): unknown {
    const obj: any = {};
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    if (message.jsonCreateClaimRequest !== "") {
      obj.jsonCreateClaimRequest = message.jsonCreateClaimRequest;
    }
    if (message.requestSignature.length !== 0) {
      obj.requestSignature = base64FromBytes(message.requestSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<RequestClaimOnAvsRequest>): RequestClaimOnAvsRequest {
    return RequestClaimOnAvsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestClaimOnAvsRequest>): RequestClaimOnAvsRequest {
    const message = createBaseRequestClaimOnAvsRequest();
    message.chainId = object.chainId ?? 0;
    message.jsonCreateClaimRequest = object.jsonCreateClaimRequest ?? "";
    message.requestSignature = object.requestSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRequestClaimOnAvsResponse(): RequestClaimOnAvsResponse {
  return { txHash: "", taskIndex: 0, jsonTask: "" };
}

export const RequestClaimOnAvsResponse: MessageFns<RequestClaimOnAvsResponse> = {
  encode(message: RequestClaimOnAvsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    if (message.taskIndex !== 0) {
      writer.uint32(16).uint32(message.taskIndex);
    }
    if (message.jsonTask !== "") {
      writer.uint32(26).string(message.jsonTask);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestClaimOnAvsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestClaimOnAvsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.taskIndex = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.jsonTask = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestClaimOnAvsResponse {
    return {
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      taskIndex: isSet(object.taskIndex) ? globalThis.Number(object.taskIndex) : 0,
      jsonTask: isSet(object.jsonTask) ? globalThis.String(object.jsonTask) : "",
    };
  },

  toJSON(message: RequestClaimOnAvsResponse): unknown {
    const obj: any = {};
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.taskIndex !== 0) {
      obj.taskIndex = Math.round(message.taskIndex);
    }
    if (message.jsonTask !== "") {
      obj.jsonTask = message.jsonTask;
    }
    return obj;
  },

  create(base?: DeepPartial<RequestClaimOnAvsResponse>): RequestClaimOnAvsResponse {
    return RequestClaimOnAvsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestClaimOnAvsResponse>): RequestClaimOnAvsResponse {
    const message = createBaseRequestClaimOnAvsResponse();
    message.txHash = object.txHash ?? "";
    message.taskIndex = object.taskIndex ?? 0;
    message.jsonTask = object.jsonTask ?? "";
    return message;
  },
};

function createBaseCompleteClaimOnAvsRequest(): CompleteClaimOnAvsRequest {
  return { chainId: 0, taskIndex: 0, completedTaskJson: "" };
}

export const CompleteClaimOnAvsRequest: MessageFns<CompleteClaimOnAvsRequest> = {
  encode(message: CompleteClaimOnAvsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== 0) {
      writer.uint32(8).uint32(message.chainId);
    }
    if (message.taskIndex !== 0) {
      writer.uint32(16).uint32(message.taskIndex);
    }
    if (message.completedTaskJson !== "") {
      writer.uint32(26).string(message.completedTaskJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteClaimOnAvsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteClaimOnAvsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.chainId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.taskIndex = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.completedTaskJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteClaimOnAvsRequest {
    return {
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
      taskIndex: isSet(object.taskIndex) ? globalThis.Number(object.taskIndex) : 0,
      completedTaskJson: isSet(object.completedTaskJson) ? globalThis.String(object.completedTaskJson) : "",
    };
  },

  toJSON(message: CompleteClaimOnAvsRequest): unknown {
    const obj: any = {};
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    if (message.taskIndex !== 0) {
      obj.taskIndex = Math.round(message.taskIndex);
    }
    if (message.completedTaskJson !== "") {
      obj.completedTaskJson = message.completedTaskJson;
    }
    return obj;
  },

  create(base?: DeepPartial<CompleteClaimOnAvsRequest>): CompleteClaimOnAvsRequest {
    return CompleteClaimOnAvsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompleteClaimOnAvsRequest>): CompleteClaimOnAvsRequest {
    const message = createBaseCompleteClaimOnAvsRequest();
    message.chainId = object.chainId ?? 0;
    message.taskIndex = object.taskIndex ?? 0;
    message.completedTaskJson = object.completedTaskJson ?? "";
    return message;
  },
};

function createBaseCompleteClaimOnAvsResponse(): CompleteClaimOnAvsResponse {
  return { txHash: "", taskCompletedObjectJson: "" };
}

export const CompleteClaimOnAvsResponse: MessageFns<CompleteClaimOnAvsResponse> = {
  encode(message: CompleteClaimOnAvsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    if (message.taskCompletedObjectJson !== "") {
      writer.uint32(18).string(message.taskCompletedObjectJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteClaimOnAvsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteClaimOnAvsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskCompletedObjectJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteClaimOnAvsResponse {
    return {
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      taskCompletedObjectJson: isSet(object.taskCompletedObjectJson)
        ? globalThis.String(object.taskCompletedObjectJson)
        : "",
    };
  },

  toJSON(message: CompleteClaimOnAvsResponse): unknown {
    const obj: any = {};
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.taskCompletedObjectJson !== "") {
      obj.taskCompletedObjectJson = message.taskCompletedObjectJson;
    }
    return obj;
  },

  create(base?: DeepPartial<CompleteClaimOnAvsResponse>): CompleteClaimOnAvsResponse {
    return CompleteClaimOnAvsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompleteClaimOnAvsResponse>): CompleteClaimOnAvsResponse {
    const message = createBaseCompleteClaimOnAvsResponse();
    message.txHash = object.txHash ?? "";
    message.taskCompletedObjectJson = object.taskCompletedObjectJson ?? "";
    return message;
  },
};

function createBaseCreateTaskOnMechainRequest(): CreateTaskOnMechainRequest {
  return { timestamp: 0 };
}

export const CreateTaskOnMechainRequest: MessageFns<CreateTaskOnMechainRequest> = {
  encode(message: CreateTaskOnMechainRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== 0) {
      writer.uint32(8).uint32(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTaskOnMechainRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTaskOnMechainRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTaskOnMechainRequest {
    return { timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0 };
  },

  toJSON(message: CreateTaskOnMechainRequest): unknown {
    const obj: any = {};
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTaskOnMechainRequest>): CreateTaskOnMechainRequest {
    return CreateTaskOnMechainRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTaskOnMechainRequest>): CreateTaskOnMechainRequest {
    const message = createBaseCreateTaskOnMechainRequest();
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseCreateTaskOnMechainResponse(): CreateTaskOnMechainResponse {
  return { taskId: 0, requiredAttestors: 0, hosts: [] };
}

export const CreateTaskOnMechainResponse: MessageFns<CreateTaskOnMechainResponse> = {
  encode(message: CreateTaskOnMechainResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== 0) {
      writer.uint32(8).uint32(message.taskId);
    }
    if (message.requiredAttestors !== 0) {
      writer.uint32(16).uint32(message.requiredAttestors);
    }
    for (const v of message.hosts) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTaskOnMechainResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTaskOnMechainResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.taskId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.requiredAttestors = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hosts.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTaskOnMechainResponse {
    return {
      taskId: isSet(object.taskId) ? globalThis.Number(object.taskId) : 0,
      requiredAttestors: isSet(object.requiredAttestors) ? globalThis.Number(object.requiredAttestors) : 0,
      hosts: globalThis.Array.isArray(object?.hosts) ? object.hosts.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CreateTaskOnMechainResponse): unknown {
    const obj: any = {};
    if (message.taskId !== 0) {
      obj.taskId = Math.round(message.taskId);
    }
    if (message.requiredAttestors !== 0) {
      obj.requiredAttestors = Math.round(message.requiredAttestors);
    }
    if (message.hosts?.length) {
      obj.hosts = message.hosts;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTaskOnMechainResponse>): CreateTaskOnMechainResponse {
    return CreateTaskOnMechainResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTaskOnMechainResponse>): CreateTaskOnMechainResponse {
    const message = createBaseCreateTaskOnMechainResponse();
    message.taskId = object.taskId ?? 0;
    message.requiredAttestors = object.requiredAttestors ?? 0;
    message.hosts = object.hosts?.map((e) => e) || [];
    return message;
  },
};

function createBaseAuthenticatedUserData(): AuthenticatedUserData {
  return { id: "", createdAt: 0, expiresAt: 0, hostWhitelist: [] };
}

export const AuthenticatedUserData: MessageFns<AuthenticatedUserData> = {
  encode(message: AuthenticatedUserData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== 0) {
      writer.uint32(16).uint32(message.createdAt);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(24).uint32(message.expiresAt);
    }
    for (const v of message.hostWhitelist) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticatedUserData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticatedUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.createdAt = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expiresAt = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hostWhitelist.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticatedUserData {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      expiresAt: isSet(object.expiresAt) ? globalThis.Number(object.expiresAt) : 0,
      hostWhitelist: globalThis.Array.isArray(object?.hostWhitelist)
        ? object.hostWhitelist.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AuthenticatedUserData): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    if (message.hostWhitelist?.length) {
      obj.hostWhitelist = message.hostWhitelist;
    }
    return obj;
  },

  create(base?: DeepPartial<AuthenticatedUserData>): AuthenticatedUserData {
    return AuthenticatedUserData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthenticatedUserData>): AuthenticatedUserData {
    const message = createBaseAuthenticatedUserData();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.expiresAt = object.expiresAt ?? 0;
    message.hostWhitelist = object.hostWhitelist?.map((e) => e) || [];
    return message;
  },
};

function createBaseAuthenticationRequest(): AuthenticationRequest {
  return { data: undefined, signature: new Uint8Array(0) };
}

export const AuthenticationRequest: MessageFns<AuthenticationRequest> = {
  encode(message: AuthenticationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      AuthenticatedUserData.encode(message.data, writer.uint32(10).fork()).join();
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = AuthenticatedUserData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticationRequest {
    return {
      data: isSet(object.data) ? AuthenticatedUserData.fromJSON(object.data) : undefined,
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: AuthenticationRequest): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = AuthenticatedUserData.toJSON(message.data);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create(base?: DeepPartial<AuthenticationRequest>): AuthenticationRequest {
    return AuthenticationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthenticationRequest>): AuthenticationRequest {
    const message = createBaseAuthenticationRequest();
    message.data = (object.data !== undefined && object.data !== null)
      ? AuthenticatedUserData.fromPartial(object.data)
      : undefined;
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseInitRequest(): InitRequest {
  return { clientVersion: 0, signatureType: 0, auth: undefined };
}

export const InitRequest: MessageFns<InitRequest> = {
  encode(message: InitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientVersion !== 0) {
      writer.uint32(16).int32(message.clientVersion);
    }
    if (message.signatureType !== 0) {
      writer.uint32(24).int32(message.signatureType);
    }
    if (message.auth !== undefined) {
      AuthenticationRequest.encode(message.auth, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clientVersion = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.signatureType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.auth = AuthenticationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitRequest {
    return {
      clientVersion: isSet(object.clientVersion) ? attestorVersionFromJSON(object.clientVersion) : 0,
      signatureType: isSet(object.signatureType) ? serviceSignatureTypeFromJSON(object.signatureType) : 0,
      auth: isSet(object.auth) ? AuthenticationRequest.fromJSON(object.auth) : undefined,
    };
  },

  toJSON(message: InitRequest): unknown {
    const obj: any = {};
    if (message.clientVersion !== 0) {
      obj.clientVersion = attestorVersionToJSON(message.clientVersion);
    }
    if (message.signatureType !== 0) {
      obj.signatureType = serviceSignatureTypeToJSON(message.signatureType);
    }
    if (message.auth !== undefined) {
      obj.auth = AuthenticationRequest.toJSON(message.auth);
    }
    return obj;
  },

  create(base?: DeepPartial<InitRequest>): InitRequest {
    return InitRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitRequest>): InitRequest {
    const message = createBaseInitRequest();
    message.clientVersion = object.clientVersion ?? 0;
    message.signatureType = object.signatureType ?? 0;
    message.auth = (object.auth !== undefined && object.auth !== null)
      ? AuthenticationRequest.fromPartial(object.auth)
      : undefined;
    return message;
  },
};

function createBaseInitResponse(): InitResponse {
  return { toprfPublicKey: new Uint8Array(0) };
}

export const InitResponse: MessageFns<InitResponse> = {
  encode(message: InitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toprfPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.toprfPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toprfPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitResponse {
    return {
      toprfPublicKey: isSet(object.toprfPublicKey) ? bytesFromBase64(object.toprfPublicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: InitResponse): unknown {
    const obj: any = {};
    if (message.toprfPublicKey.length !== 0) {
      obj.toprfPublicKey = base64FromBytes(message.toprfPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<InitResponse>): InitResponse {
    return InitResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitResponse>): InitResponse {
    const message = createBaseInitResponse();
    message.toprfPublicKey = object.toprfPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTOPRFRequest(): TOPRFRequest {
  return { maskedData: new Uint8Array(0), engine: 0 };
}

export const TOPRFRequest: MessageFns<TOPRFRequest> = {
  encode(message: TOPRFRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maskedData.length !== 0) {
      writer.uint32(10).bytes(message.maskedData);
    }
    if (message.engine !== 0) {
      writer.uint32(16).int32(message.engine);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TOPRFRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTOPRFRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.maskedData = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.engine = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TOPRFRequest {
    return {
      maskedData: isSet(object.maskedData) ? bytesFromBase64(object.maskedData) : new Uint8Array(0),
      engine: isSet(object.engine) ? zKProofEngineFromJSON(object.engine) : 0,
    };
  },

  toJSON(message: TOPRFRequest): unknown {
    const obj: any = {};
    if (message.maskedData.length !== 0) {
      obj.maskedData = base64FromBytes(message.maskedData);
    }
    if (message.engine !== 0) {
      obj.engine = zKProofEngineToJSON(message.engine);
    }
    return obj;
  },

  create(base?: DeepPartial<TOPRFRequest>): TOPRFRequest {
    return TOPRFRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TOPRFRequest>): TOPRFRequest {
    const message = createBaseTOPRFRequest();
    message.maskedData = object.maskedData ?? new Uint8Array(0);
    message.engine = object.engine ?? 0;
    return message;
  },
};

function createBaseTOPRFResponse(): TOPRFResponse {
  return {
    publicKeyShare: new Uint8Array(0),
    evaluated: new Uint8Array(0),
    c: new Uint8Array(0),
    r: new Uint8Array(0),
  };
}

export const TOPRFResponse: MessageFns<TOPRFResponse> = {
  encode(message: TOPRFResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKeyShare.length !== 0) {
      writer.uint32(10).bytes(message.publicKeyShare);
    }
    if (message.evaluated.length !== 0) {
      writer.uint32(18).bytes(message.evaluated);
    }
    if (message.c.length !== 0) {
      writer.uint32(26).bytes(message.c);
    }
    if (message.r.length !== 0) {
      writer.uint32(34).bytes(message.r);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TOPRFResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTOPRFResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKeyShare = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.evaluated = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.c = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.r = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TOPRFResponse {
    return {
      publicKeyShare: isSet(object.publicKeyShare) ? bytesFromBase64(object.publicKeyShare) : new Uint8Array(0),
      evaluated: isSet(object.evaluated) ? bytesFromBase64(object.evaluated) : new Uint8Array(0),
      c: isSet(object.c) ? bytesFromBase64(object.c) : new Uint8Array(0),
      r: isSet(object.r) ? bytesFromBase64(object.r) : new Uint8Array(0),
    };
  },

  toJSON(message: TOPRFResponse): unknown {
    const obj: any = {};
    if (message.publicKeyShare.length !== 0) {
      obj.publicKeyShare = base64FromBytes(message.publicKeyShare);
    }
    if (message.evaluated.length !== 0) {
      obj.evaluated = base64FromBytes(message.evaluated);
    }
    if (message.c.length !== 0) {
      obj.c = base64FromBytes(message.c);
    }
    if (message.r.length !== 0) {
      obj.r = base64FromBytes(message.r);
    }
    return obj;
  },

  create(base?: DeepPartial<TOPRFResponse>): TOPRFResponse {
    return TOPRFResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TOPRFResponse>): TOPRFResponse {
    const message = createBaseTOPRFResponse();
    message.publicKeyShare = object.publicKeyShare ?? new Uint8Array(0);
    message.evaluated = object.evaluated ?? new Uint8Array(0);
    message.c = object.c ?? new Uint8Array(0);
    message.r = object.r ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRPCMessage(): RPCMessage {
  return {
    id: 0,
    initRequest: undefined,
    initResponse: undefined,
    connectionTerminationAlert: undefined,
    requestError: undefined,
    createTunnelRequest: undefined,
    createTunnelResponse: undefined,
    disconnectTunnelRequest: undefined,
    disconnectTunnelResponse: undefined,
    tunnelMessage: undefined,
    tunnelDisconnectEvent: undefined,
    claimTunnelRequest: undefined,
    claimTunnelResponse: undefined,
    createClaimOnChainRequest: undefined,
    createClaimOnChainResponse: undefined,
    completeClaimOnChainRequest: undefined,
    completeClaimOnChainResponse: undefined,
    toprfRequest: undefined,
    toprfResponse: undefined,
    createTaskOnMechainRequest: undefined,
    createTaskOnMechainResponse: undefined,
  };
}

export const RPCMessage: MessageFns<RPCMessage> = {
  encode(message: RPCMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.initRequest !== undefined) {
      InitRequest.encode(message.initRequest, writer.uint32(18).fork()).join();
    }
    if (message.initResponse !== undefined) {
      InitResponse.encode(message.initResponse, writer.uint32(26).fork()).join();
    }
    if (message.connectionTerminationAlert !== undefined) {
      ErrorData.encode(message.connectionTerminationAlert, writer.uint32(34).fork()).join();
    }
    if (message.requestError !== undefined) {
      ErrorData.encode(message.requestError, writer.uint32(42).fork()).join();
    }
    if (message.createTunnelRequest !== undefined) {
      CreateTunnelRequest.encode(message.createTunnelRequest, writer.uint32(50).fork()).join();
    }
    if (message.createTunnelResponse !== undefined) {
      Empty.encode(message.createTunnelResponse, writer.uint32(58).fork()).join();
    }
    if (message.disconnectTunnelRequest !== undefined) {
      DisconnectTunnelRequest.encode(message.disconnectTunnelRequest, writer.uint32(66).fork()).join();
    }
    if (message.disconnectTunnelResponse !== undefined) {
      Empty.encode(message.disconnectTunnelResponse, writer.uint32(74).fork()).join();
    }
    if (message.tunnelMessage !== undefined) {
      TunnelMessage.encode(message.tunnelMessage, writer.uint32(82).fork()).join();
    }
    if (message.tunnelDisconnectEvent !== undefined) {
      TunnelDisconnectEvent.encode(message.tunnelDisconnectEvent, writer.uint32(90).fork()).join();
    }
    if (message.claimTunnelRequest !== undefined) {
      ClaimTunnelRequest.encode(message.claimTunnelRequest, writer.uint32(98).fork()).join();
    }
    if (message.claimTunnelResponse !== undefined) {
      ClaimTunnelResponse.encode(message.claimTunnelResponse, writer.uint32(106).fork()).join();
    }
    if (message.createClaimOnChainRequest !== undefined) {
      RequestClaimOnAvsRequest.encode(message.createClaimOnChainRequest, writer.uint32(114).fork()).join();
    }
    if (message.createClaimOnChainResponse !== undefined) {
      RequestClaimOnAvsResponse.encode(message.createClaimOnChainResponse, writer.uint32(122).fork()).join();
    }
    if (message.completeClaimOnChainRequest !== undefined) {
      CompleteClaimOnAvsRequest.encode(message.completeClaimOnChainRequest, writer.uint32(130).fork()).join();
    }
    if (message.completeClaimOnChainResponse !== undefined) {
      CompleteClaimOnAvsResponse.encode(message.completeClaimOnChainResponse, writer.uint32(138).fork()).join();
    }
    if (message.toprfRequest !== undefined) {
      TOPRFRequest.encode(message.toprfRequest, writer.uint32(146).fork()).join();
    }
    if (message.toprfResponse !== undefined) {
      TOPRFResponse.encode(message.toprfResponse, writer.uint32(154).fork()).join();
    }
    if (message.createTaskOnMechainRequest !== undefined) {
      CreateTaskOnMechainRequest.encode(message.createTaskOnMechainRequest, writer.uint32(162).fork()).join();
    }
    if (message.createTaskOnMechainResponse !== undefined) {
      CreateTaskOnMechainResponse.encode(message.createTaskOnMechainResponse, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RPCMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRPCMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.initRequest = InitRequest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.initResponse = InitResponse.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.connectionTerminationAlert = ErrorData.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requestError = ErrorData.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createTunnelRequest = CreateTunnelRequest.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createTunnelResponse = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.disconnectTunnelRequest = DisconnectTunnelRequest.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.disconnectTunnelResponse = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.tunnelMessage = TunnelMessage.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.tunnelDisconnectEvent = TunnelDisconnectEvent.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.claimTunnelRequest = ClaimTunnelRequest.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.claimTunnelResponse = ClaimTunnelResponse.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.createClaimOnChainRequest = RequestClaimOnAvsRequest.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.createClaimOnChainResponse = RequestClaimOnAvsResponse.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.completeClaimOnChainRequest = CompleteClaimOnAvsRequest.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.completeClaimOnChainResponse = CompleteClaimOnAvsResponse.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.toprfRequest = TOPRFRequest.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.toprfResponse = TOPRFResponse.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.createTaskOnMechainRequest = CreateTaskOnMechainRequest.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.createTaskOnMechainResponse = CreateTaskOnMechainResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RPCMessage {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      initRequest: isSet(object.initRequest) ? InitRequest.fromJSON(object.initRequest) : undefined,
      initResponse: isSet(object.initResponse) ? InitResponse.fromJSON(object.initResponse) : undefined,
      connectionTerminationAlert: isSet(object.connectionTerminationAlert)
        ? ErrorData.fromJSON(object.connectionTerminationAlert)
        : undefined,
      requestError: isSet(object.requestError) ? ErrorData.fromJSON(object.requestError) : undefined,
      createTunnelRequest: isSet(object.createTunnelRequest)
        ? CreateTunnelRequest.fromJSON(object.createTunnelRequest)
        : undefined,
      createTunnelResponse: isSet(object.createTunnelResponse)
        ? Empty.fromJSON(object.createTunnelResponse)
        : undefined,
      disconnectTunnelRequest: isSet(object.disconnectTunnelRequest)
        ? DisconnectTunnelRequest.fromJSON(object.disconnectTunnelRequest)
        : undefined,
      disconnectTunnelResponse: isSet(object.disconnectTunnelResponse)
        ? Empty.fromJSON(object.disconnectTunnelResponse)
        : undefined,
      tunnelMessage: isSet(object.tunnelMessage) ? TunnelMessage.fromJSON(object.tunnelMessage) : undefined,
      tunnelDisconnectEvent: isSet(object.tunnelDisconnectEvent)
        ? TunnelDisconnectEvent.fromJSON(object.tunnelDisconnectEvent)
        : undefined,
      claimTunnelRequest: isSet(object.claimTunnelRequest)
        ? ClaimTunnelRequest.fromJSON(object.claimTunnelRequest)
        : undefined,
      claimTunnelResponse: isSet(object.claimTunnelResponse)
        ? ClaimTunnelResponse.fromJSON(object.claimTunnelResponse)
        : undefined,
      createClaimOnChainRequest: isSet(object.createClaimOnChainRequest)
        ? RequestClaimOnAvsRequest.fromJSON(object.createClaimOnChainRequest)
        : undefined,
      createClaimOnChainResponse: isSet(object.createClaimOnChainResponse)
        ? RequestClaimOnAvsResponse.fromJSON(object.createClaimOnChainResponse)
        : undefined,
      completeClaimOnChainRequest: isSet(object.completeClaimOnChainRequest)
        ? CompleteClaimOnAvsRequest.fromJSON(object.completeClaimOnChainRequest)
        : undefined,
      completeClaimOnChainResponse: isSet(object.completeClaimOnChainResponse)
        ? CompleteClaimOnAvsResponse.fromJSON(object.completeClaimOnChainResponse)
        : undefined,
      toprfRequest: isSet(object.toprfRequest) ? TOPRFRequest.fromJSON(object.toprfRequest) : undefined,
      toprfResponse: isSet(object.toprfResponse) ? TOPRFResponse.fromJSON(object.toprfResponse) : undefined,
      createTaskOnMechainRequest: isSet(object.createTaskOnMechainRequest)
        ? CreateTaskOnMechainRequest.fromJSON(object.createTaskOnMechainRequest)
        : undefined,
      createTaskOnMechainResponse: isSet(object.createTaskOnMechainResponse)
        ? CreateTaskOnMechainResponse.fromJSON(object.createTaskOnMechainResponse)
        : undefined,
    };
  },

  toJSON(message: RPCMessage): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.initRequest !== undefined) {
      obj.initRequest = InitRequest.toJSON(message.initRequest);
    }
    if (message.initResponse !== undefined) {
      obj.initResponse = InitResponse.toJSON(message.initResponse);
    }
    if (message.connectionTerminationAlert !== undefined) {
      obj.connectionTerminationAlert = ErrorData.toJSON(message.connectionTerminationAlert);
    }
    if (message.requestError !== undefined) {
      obj.requestError = ErrorData.toJSON(message.requestError);
    }
    if (message.createTunnelRequest !== undefined) {
      obj.createTunnelRequest = CreateTunnelRequest.toJSON(message.createTunnelRequest);
    }
    if (message.createTunnelResponse !== undefined) {
      obj.createTunnelResponse = Empty.toJSON(message.createTunnelResponse);
    }
    if (message.disconnectTunnelRequest !== undefined) {
      obj.disconnectTunnelRequest = DisconnectTunnelRequest.toJSON(message.disconnectTunnelRequest);
    }
    if (message.disconnectTunnelResponse !== undefined) {
      obj.disconnectTunnelResponse = Empty.toJSON(message.disconnectTunnelResponse);
    }
    if (message.tunnelMessage !== undefined) {
      obj.tunnelMessage = TunnelMessage.toJSON(message.tunnelMessage);
    }
    if (message.tunnelDisconnectEvent !== undefined) {
      obj.tunnelDisconnectEvent = TunnelDisconnectEvent.toJSON(message.tunnelDisconnectEvent);
    }
    if (message.claimTunnelRequest !== undefined) {
      obj.claimTunnelRequest = ClaimTunnelRequest.toJSON(message.claimTunnelRequest);
    }
    if (message.claimTunnelResponse !== undefined) {
      obj.claimTunnelResponse = ClaimTunnelResponse.toJSON(message.claimTunnelResponse);
    }
    if (message.createClaimOnChainRequest !== undefined) {
      obj.createClaimOnChainRequest = RequestClaimOnAvsRequest.toJSON(message.createClaimOnChainRequest);
    }
    if (message.createClaimOnChainResponse !== undefined) {
      obj.createClaimOnChainResponse = RequestClaimOnAvsResponse.toJSON(message.createClaimOnChainResponse);
    }
    if (message.completeClaimOnChainRequest !== undefined) {
      obj.completeClaimOnChainRequest = CompleteClaimOnAvsRequest.toJSON(message.completeClaimOnChainRequest);
    }
    if (message.completeClaimOnChainResponse !== undefined) {
      obj.completeClaimOnChainResponse = CompleteClaimOnAvsResponse.toJSON(message.completeClaimOnChainResponse);
    }
    if (message.toprfRequest !== undefined) {
      obj.toprfRequest = TOPRFRequest.toJSON(message.toprfRequest);
    }
    if (message.toprfResponse !== undefined) {
      obj.toprfResponse = TOPRFResponse.toJSON(message.toprfResponse);
    }
    if (message.createTaskOnMechainRequest !== undefined) {
      obj.createTaskOnMechainRequest = CreateTaskOnMechainRequest.toJSON(message.createTaskOnMechainRequest);
    }
    if (message.createTaskOnMechainResponse !== undefined) {
      obj.createTaskOnMechainResponse = CreateTaskOnMechainResponse.toJSON(message.createTaskOnMechainResponse);
    }
    return obj;
  },

  create(base?: DeepPartial<RPCMessage>): RPCMessage {
    return RPCMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RPCMessage>): RPCMessage {
    const message = createBaseRPCMessage();
    message.id = object.id ?? 0;
    message.initRequest = (object.initRequest !== undefined && object.initRequest !== null)
      ? InitRequest.fromPartial(object.initRequest)
      : undefined;
    message.initResponse = (object.initResponse !== undefined && object.initResponse !== null)
      ? InitResponse.fromPartial(object.initResponse)
      : undefined;
    message.connectionTerminationAlert =
      (object.connectionTerminationAlert !== undefined && object.connectionTerminationAlert !== null)
        ? ErrorData.fromPartial(object.connectionTerminationAlert)
        : undefined;
    message.requestError = (object.requestError !== undefined && object.requestError !== null)
      ? ErrorData.fromPartial(object.requestError)
      : undefined;
    message.createTunnelRequest = (object.createTunnelRequest !== undefined && object.createTunnelRequest !== null)
      ? CreateTunnelRequest.fromPartial(object.createTunnelRequest)
      : undefined;
    message.createTunnelResponse = (object.createTunnelResponse !== undefined && object.createTunnelResponse !== null)
      ? Empty.fromPartial(object.createTunnelResponse)
      : undefined;
    message.disconnectTunnelRequest =
      (object.disconnectTunnelRequest !== undefined && object.disconnectTunnelRequest !== null)
        ? DisconnectTunnelRequest.fromPartial(object.disconnectTunnelRequest)
        : undefined;
    message.disconnectTunnelResponse =
      (object.disconnectTunnelResponse !== undefined && object.disconnectTunnelResponse !== null)
        ? Empty.fromPartial(object.disconnectTunnelResponse)
        : undefined;
    message.tunnelMessage = (object.tunnelMessage !== undefined && object.tunnelMessage !== null)
      ? TunnelMessage.fromPartial(object.tunnelMessage)
      : undefined;
    message.tunnelDisconnectEvent =
      (object.tunnelDisconnectEvent !== undefined && object.tunnelDisconnectEvent !== null)
        ? TunnelDisconnectEvent.fromPartial(object.tunnelDisconnectEvent)
        : undefined;
    message.claimTunnelRequest = (object.claimTunnelRequest !== undefined && object.claimTunnelRequest !== null)
      ? ClaimTunnelRequest.fromPartial(object.claimTunnelRequest)
      : undefined;
    message.claimTunnelResponse = (object.claimTunnelResponse !== undefined && object.claimTunnelResponse !== null)
      ? ClaimTunnelResponse.fromPartial(object.claimTunnelResponse)
      : undefined;
    message.createClaimOnChainRequest =
      (object.createClaimOnChainRequest !== undefined && object.createClaimOnChainRequest !== null)
        ? RequestClaimOnAvsRequest.fromPartial(object.createClaimOnChainRequest)
        : undefined;
    message.createClaimOnChainResponse =
      (object.createClaimOnChainResponse !== undefined && object.createClaimOnChainResponse !== null)
        ? RequestClaimOnAvsResponse.fromPartial(object.createClaimOnChainResponse)
        : undefined;
    message.completeClaimOnChainRequest =
      (object.completeClaimOnChainRequest !== undefined && object.completeClaimOnChainRequest !== null)
        ? CompleteClaimOnAvsRequest.fromPartial(object.completeClaimOnChainRequest)
        : undefined;
    message.completeClaimOnChainResponse =
      (object.completeClaimOnChainResponse !== undefined && object.completeClaimOnChainResponse !== null)
        ? CompleteClaimOnAvsResponse.fromPartial(object.completeClaimOnChainResponse)
        : undefined;
    message.toprfRequest = (object.toprfRequest !== undefined && object.toprfRequest !== null)
      ? TOPRFRequest.fromPartial(object.toprfRequest)
      : undefined;
    message.toprfResponse = (object.toprfResponse !== undefined && object.toprfResponse !== null)
      ? TOPRFResponse.fromPartial(object.toprfResponse)
      : undefined;
    message.createTaskOnMechainRequest =
      (object.createTaskOnMechainRequest !== undefined && object.createTaskOnMechainRequest !== null)
        ? CreateTaskOnMechainRequest.fromPartial(object.createTaskOnMechainRequest)
        : undefined;
    message.createTaskOnMechainResponse =
      (object.createTaskOnMechainResponse !== undefined && object.createTaskOnMechainResponse !== null)
        ? CreateTaskOnMechainResponse.fromPartial(object.createTaskOnMechainResponse)
        : undefined;
    return message;
  },
};

function createBaseRPCMessages(): RPCMessages {
  return { messages: [] };
}

export const RPCMessages: MessageFns<RPCMessages> = {
  encode(message: RPCMessages, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      RPCMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RPCMessages {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRPCMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(RPCMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RPCMessages {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => RPCMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RPCMessages): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => RPCMessage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RPCMessages>): RPCMessages {
    return RPCMessages.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RPCMessages>): RPCMessages {
    const message = createBaseRPCMessages();
    message.messages = object.messages?.map((e) => RPCMessage.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
