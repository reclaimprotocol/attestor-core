// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.5.0
//   protoc               v6.31.1
// source: tee-bundle.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "teeproto";

/** Signature wrapper used everywhere */
export enum BodyType {
  BODY_TYPE_UNSPECIFIED = 0,
  BODY_TYPE_K_OUTPUT = 1,
  BODY_TYPE_T_OUTPUT = 2,
  UNRECOGNIZED = -1,
}

export function bodyTypeFromJSON(object: any): BodyType {
  switch (object) {
    case 0:
    case "BODY_TYPE_UNSPECIFIED":
      return BodyType.BODY_TYPE_UNSPECIFIED;
    case 1:
    case "BODY_TYPE_K_OUTPUT":
      return BodyType.BODY_TYPE_K_OUTPUT;
    case 2:
    case "BODY_TYPE_T_OUTPUT":
      return BodyType.BODY_TYPE_T_OUTPUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BodyType.UNRECOGNIZED;
  }
}

export function bodyTypeToJSON(object: BodyType): string {
  switch (object) {
    case BodyType.BODY_TYPE_UNSPECIFIED:
      return "BODY_TYPE_UNSPECIFIED";
    case BodyType.BODY_TYPE_K_OUTPUT:
      return "BODY_TYPE_K_OUTPUT";
    case BodyType.BODY_TYPE_T_OUTPUT:
      return "BODY_TYPE_T_OUTPUT";
    case BodyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Common structures */
export interface RequestRedactionRange {
  start: number;
  length: number;
  /** Values: "sensitive" or "sensitive_proof" */
  type: string;
}

export interface ResponseRedactionRange {
  start: number;
  length: number;
}

export interface SignedRedactedDecryptionStream {
  redactedStream: Uint8Array;
  seqNum: number;
}

/** Certificate information extracted during TLS handshake */
export interface CertificateInfo {
  commonName: string;
  issuerCommonName: string;
  notBeforeUnix: number;
  notAfterUnix: number;
  dnsNames: string[];
}

/** Handshake secrets disclosed for verification/display */
export interface HandshakeSecrets {
  handshakeKey: Uint8Array;
  handshakeIv: Uint8Array;
  /** uint16 fits here */
  cipherSuite: number;
  algorithm: string;
}

/** Commitment opening for proof stream */
export interface Opening {
  /** Str_SP */
  proofStream: Uint8Array;
}

export interface KOutputPayload {
  /** R_red */
  redactedRequest: Uint8Array;
  requestRedactionRanges: RequestRedactionRange[];
  /** NEW: Single response decryption keystream */
  consolidatedResponseKeystream: Uint8Array;
  /** NEW: Structured cert data instead of handshake packets */
  certificateInfo: CertificateInfo | undefined;
  responseRedactionRanges: ResponseRedactionRange[];
  /** Unix timestamp in milliseconds when payload was created (SIGNED) */
  timestampMs: number;
}

export interface TOutputPayload {
  /** NEW: Single consolidated ciphertext instead of individual packets */
  consolidatedResponseCiphertext: Uint8Array;
  /** R_SP streams signed by TEE_T for cryptographic verification */
  requestProofStreams: Uint8Array[];
  /** Unix timestamp in milliseconds when payload was created (SIGNED) */
  timestampMs: number;
}

/** Attestation report with structured data */
export interface AttestationReport {
  /** "nitro" or "gcp" */
  type: string;
  /** raw provider-specific attestation bytes */
  report: Uint8Array;
}

export interface SignedMessage {
  bodyType: BodyType;
  /** serialized deterministic KOutputPayload or TOutputPayload */
  body: Uint8Array;
  /** ETH address (20 bytes, standalone mode only) */
  ethAddress: Uint8Array;
  /** signature over body bytes */
  signature: Uint8Array;
  /** full attestation (enclave mode only) */
  attestationReport: AttestationReport | undefined;
}

/** OPRF verification data for a single hashed range */
export interface OPRFVerificationData {
  /** Position in the consolidated TLS stream */
  streamPos: number;
  /** Length of data in the stream */
  streamLength: number;
  /** ZK proof and public parameters */
  publicSignalsJson: Uint8Array;
}

/** Single artefact produced by client for offline verification */
export interface VerificationBundle {
  /** Signed transcripts */
  teekSigned:
    | SignedMessage
    | undefined;
  /** BODY_TYPE_T_OUTPUT */
  teetSigned:
    | SignedMessage
    | undefined;
  /** OPRF verification data for hashed ranges */
  oprfVerifications: OPRFVerificationData[];
}

function createBaseRequestRedactionRange(): RequestRedactionRange {
  return { start: 0, length: 0, type: "" };
}

export const RequestRedactionRange: MessageFns<RequestRedactionRange> = {
  encode(message: RequestRedactionRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.length !== 0) {
      writer.uint32(16).int32(message.length);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestRedactionRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestRedactionRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.start = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.length = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestRedactionRange {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: RequestRedactionRange): unknown {
    const obj: any = {};
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create(base?: DeepPartial<RequestRedactionRange>): RequestRedactionRange {
    return RequestRedactionRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestRedactionRange>): RequestRedactionRange {
    const message = createBaseRequestRedactionRange();
    message.start = object.start ?? 0;
    message.length = object.length ?? 0;
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseResponseRedactionRange(): ResponseRedactionRange {
  return { start: 0, length: 0 };
}

export const ResponseRedactionRange: MessageFns<ResponseRedactionRange> = {
  encode(message: ResponseRedactionRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.length !== 0) {
      writer.uint32(16).int32(message.length);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseRedactionRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseRedactionRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.start = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.length = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseRedactionRange {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
    };
  },

  toJSON(message: ResponseRedactionRange): unknown {
    const obj: any = {};
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    return obj;
  },

  create(base?: DeepPartial<ResponseRedactionRange>): ResponseRedactionRange {
    return ResponseRedactionRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResponseRedactionRange>): ResponseRedactionRange {
    const message = createBaseResponseRedactionRange();
    message.start = object.start ?? 0;
    message.length = object.length ?? 0;
    return message;
  },
};

function createBaseSignedRedactedDecryptionStream(): SignedRedactedDecryptionStream {
  return { redactedStream: new Uint8Array(0), seqNum: 0 };
}

export const SignedRedactedDecryptionStream: MessageFns<SignedRedactedDecryptionStream> = {
  encode(message: SignedRedactedDecryptionStream, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.redactedStream.length !== 0) {
      writer.uint32(10).bytes(message.redactedStream);
    }
    if (message.seqNum !== 0) {
      writer.uint32(16).uint64(message.seqNum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignedRedactedDecryptionStream {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedRedactedDecryptionStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.redactedStream = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.seqNum = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedRedactedDecryptionStream {
    return {
      redactedStream: isSet(object.redactedStream) ? bytesFromBase64(object.redactedStream) : new Uint8Array(0),
      seqNum: isSet(object.seqNum) ? globalThis.Number(object.seqNum) : 0,
    };
  },

  toJSON(message: SignedRedactedDecryptionStream): unknown {
    const obj: any = {};
    if (message.redactedStream.length !== 0) {
      obj.redactedStream = base64FromBytes(message.redactedStream);
    }
    if (message.seqNum !== 0) {
      obj.seqNum = Math.round(message.seqNum);
    }
    return obj;
  },

  create(base?: DeepPartial<SignedRedactedDecryptionStream>): SignedRedactedDecryptionStream {
    return SignedRedactedDecryptionStream.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedRedactedDecryptionStream>): SignedRedactedDecryptionStream {
    const message = createBaseSignedRedactedDecryptionStream();
    message.redactedStream = object.redactedStream ?? new Uint8Array(0);
    message.seqNum = object.seqNum ?? 0;
    return message;
  },
};

function createBaseCertificateInfo(): CertificateInfo {
  return { commonName: "", issuerCommonName: "", notBeforeUnix: 0, notAfterUnix: 0, dnsNames: [] };
}

export const CertificateInfo: MessageFns<CertificateInfo> = {
  encode(message: CertificateInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commonName !== "") {
      writer.uint32(10).string(message.commonName);
    }
    if (message.issuerCommonName !== "") {
      writer.uint32(18).string(message.issuerCommonName);
    }
    if (message.notBeforeUnix !== 0) {
      writer.uint32(24).uint64(message.notBeforeUnix);
    }
    if (message.notAfterUnix !== 0) {
      writer.uint32(32).uint64(message.notAfterUnix);
    }
    for (const v of message.dnsNames) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commonName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.issuerCommonName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.notBeforeUnix = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.notAfterUnix = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dnsNames.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateInfo {
    return {
      commonName: isSet(object.commonName) ? globalThis.String(object.commonName) : "",
      issuerCommonName: isSet(object.issuerCommonName) ? globalThis.String(object.issuerCommonName) : "",
      notBeforeUnix: isSet(object.notBeforeUnix) ? globalThis.Number(object.notBeforeUnix) : 0,
      notAfterUnix: isSet(object.notAfterUnix) ? globalThis.Number(object.notAfterUnix) : 0,
      dnsNames: globalThis.Array.isArray(object?.dnsNames) ? object.dnsNames.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CertificateInfo): unknown {
    const obj: any = {};
    if (message.commonName !== "") {
      obj.commonName = message.commonName;
    }
    if (message.issuerCommonName !== "") {
      obj.issuerCommonName = message.issuerCommonName;
    }
    if (message.notBeforeUnix !== 0) {
      obj.notBeforeUnix = Math.round(message.notBeforeUnix);
    }
    if (message.notAfterUnix !== 0) {
      obj.notAfterUnix = Math.round(message.notAfterUnix);
    }
    if (message.dnsNames?.length) {
      obj.dnsNames = message.dnsNames;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateInfo>): CertificateInfo {
    return CertificateInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateInfo>): CertificateInfo {
    const message = createBaseCertificateInfo();
    message.commonName = object.commonName ?? "";
    message.issuerCommonName = object.issuerCommonName ?? "";
    message.notBeforeUnix = object.notBeforeUnix ?? 0;
    message.notAfterUnix = object.notAfterUnix ?? 0;
    message.dnsNames = object.dnsNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseHandshakeSecrets(): HandshakeSecrets {
  return { handshakeKey: new Uint8Array(0), handshakeIv: new Uint8Array(0), cipherSuite: 0, algorithm: "" };
}

export const HandshakeSecrets: MessageFns<HandshakeSecrets> = {
  encode(message: HandshakeSecrets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.handshakeKey.length !== 0) {
      writer.uint32(10).bytes(message.handshakeKey);
    }
    if (message.handshakeIv.length !== 0) {
      writer.uint32(18).bytes(message.handshakeIv);
    }
    if (message.cipherSuite !== 0) {
      writer.uint32(24).uint32(message.cipherSuite);
    }
    if (message.algorithm !== "") {
      writer.uint32(34).string(message.algorithm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandshakeSecrets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandshakeSecrets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.handshakeKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.handshakeIv = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cipherSuite = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandshakeSecrets {
    return {
      handshakeKey: isSet(object.handshakeKey) ? bytesFromBase64(object.handshakeKey) : new Uint8Array(0),
      handshakeIv: isSet(object.handshakeIv) ? bytesFromBase64(object.handshakeIv) : new Uint8Array(0),
      cipherSuite: isSet(object.cipherSuite) ? globalThis.Number(object.cipherSuite) : 0,
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
    };
  },

  toJSON(message: HandshakeSecrets): unknown {
    const obj: any = {};
    if (message.handshakeKey.length !== 0) {
      obj.handshakeKey = base64FromBytes(message.handshakeKey);
    }
    if (message.handshakeIv.length !== 0) {
      obj.handshakeIv = base64FromBytes(message.handshakeIv);
    }
    if (message.cipherSuite !== 0) {
      obj.cipherSuite = Math.round(message.cipherSuite);
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    return obj;
  },

  create(base?: DeepPartial<HandshakeSecrets>): HandshakeSecrets {
    return HandshakeSecrets.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HandshakeSecrets>): HandshakeSecrets {
    const message = createBaseHandshakeSecrets();
    message.handshakeKey = object.handshakeKey ?? new Uint8Array(0);
    message.handshakeIv = object.handshakeIv ?? new Uint8Array(0);
    message.cipherSuite = object.cipherSuite ?? 0;
    message.algorithm = object.algorithm ?? "";
    return message;
  },
};

function createBaseOpening(): Opening {
  return { proofStream: new Uint8Array(0) };
}

export const Opening: MessageFns<Opening> = {
  encode(message: Opening, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proofStream.length !== 0) {
      writer.uint32(10).bytes(message.proofStream);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Opening {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpening();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofStream = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Opening {
    return { proofStream: isSet(object.proofStream) ? bytesFromBase64(object.proofStream) : new Uint8Array(0) };
  },

  toJSON(message: Opening): unknown {
    const obj: any = {};
    if (message.proofStream.length !== 0) {
      obj.proofStream = base64FromBytes(message.proofStream);
    }
    return obj;
  },

  create(base?: DeepPartial<Opening>): Opening {
    return Opening.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Opening>): Opening {
    const message = createBaseOpening();
    message.proofStream = object.proofStream ?? new Uint8Array(0);
    return message;
  },
};

function createBaseKOutputPayload(): KOutputPayload {
  return {
    redactedRequest: new Uint8Array(0),
    requestRedactionRanges: [],
    consolidatedResponseKeystream: new Uint8Array(0),
    certificateInfo: undefined,
    responseRedactionRanges: [],
    timestampMs: 0,
  };
}

export const KOutputPayload: MessageFns<KOutputPayload> = {
  encode(message: KOutputPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.redactedRequest.length !== 0) {
      writer.uint32(10).bytes(message.redactedRequest);
    }
    for (const v of message.requestRedactionRanges) {
      RequestRedactionRange.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.consolidatedResponseKeystream.length !== 0) {
      writer.uint32(26).bytes(message.consolidatedResponseKeystream);
    }
    if (message.certificateInfo !== undefined) {
      CertificateInfo.encode(message.certificateInfo, writer.uint32(34).fork()).join();
    }
    for (const v of message.responseRedactionRanges) {
      ResponseRedactionRange.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.timestampMs !== 0) {
      writer.uint32(48).uint64(message.timestampMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KOutputPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKOutputPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.redactedRequest = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestRedactionRanges.push(RequestRedactionRange.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.consolidatedResponseKeystream = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.certificateInfo = CertificateInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.responseRedactionRanges.push(ResponseRedactionRange.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.timestampMs = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KOutputPayload {
    return {
      redactedRequest: isSet(object.redactedRequest) ? bytesFromBase64(object.redactedRequest) : new Uint8Array(0),
      requestRedactionRanges: globalThis.Array.isArray(object?.requestRedactionRanges)
        ? object.requestRedactionRanges.map((e: any) => RequestRedactionRange.fromJSON(e))
        : [],
      consolidatedResponseKeystream: isSet(object.consolidatedResponseKeystream)
        ? bytesFromBase64(object.consolidatedResponseKeystream)
        : new Uint8Array(0),
      certificateInfo: isSet(object.certificateInfo) ? CertificateInfo.fromJSON(object.certificateInfo) : undefined,
      responseRedactionRanges: globalThis.Array.isArray(object?.responseRedactionRanges)
        ? object.responseRedactionRanges.map((e: any) => ResponseRedactionRange.fromJSON(e))
        : [],
      timestampMs: isSet(object.timestampMs) ? globalThis.Number(object.timestampMs) : 0,
    };
  },

  toJSON(message: KOutputPayload): unknown {
    const obj: any = {};
    if (message.redactedRequest.length !== 0) {
      obj.redactedRequest = base64FromBytes(message.redactedRequest);
    }
    if (message.requestRedactionRanges?.length) {
      obj.requestRedactionRanges = message.requestRedactionRanges.map((e) => RequestRedactionRange.toJSON(e));
    }
    if (message.consolidatedResponseKeystream.length !== 0) {
      obj.consolidatedResponseKeystream = base64FromBytes(message.consolidatedResponseKeystream);
    }
    if (message.certificateInfo !== undefined) {
      obj.certificateInfo = CertificateInfo.toJSON(message.certificateInfo);
    }
    if (message.responseRedactionRanges?.length) {
      obj.responseRedactionRanges = message.responseRedactionRanges.map((e) => ResponseRedactionRange.toJSON(e));
    }
    if (message.timestampMs !== 0) {
      obj.timestampMs = Math.round(message.timestampMs);
    }
    return obj;
  },

  create(base?: DeepPartial<KOutputPayload>): KOutputPayload {
    return KOutputPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KOutputPayload>): KOutputPayload {
    const message = createBaseKOutputPayload();
    message.redactedRequest = object.redactedRequest ?? new Uint8Array(0);
    message.requestRedactionRanges = object.requestRedactionRanges?.map((e) => RequestRedactionRange.fromPartial(e)) ||
      [];
    message.consolidatedResponseKeystream = object.consolidatedResponseKeystream ?? new Uint8Array(0);
    message.certificateInfo = (object.certificateInfo !== undefined && object.certificateInfo !== null)
      ? CertificateInfo.fromPartial(object.certificateInfo)
      : undefined;
    message.responseRedactionRanges =
      object.responseRedactionRanges?.map((e) => ResponseRedactionRange.fromPartial(e)) || [];
    message.timestampMs = object.timestampMs ?? 0;
    return message;
  },
};

function createBaseTOutputPayload(): TOutputPayload {
  return { consolidatedResponseCiphertext: new Uint8Array(0), requestProofStreams: [], timestampMs: 0 };
}

export const TOutputPayload: MessageFns<TOutputPayload> = {
  encode(message: TOutputPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consolidatedResponseCiphertext.length !== 0) {
      writer.uint32(10).bytes(message.consolidatedResponseCiphertext);
    }
    for (const v of message.requestProofStreams) {
      writer.uint32(18).bytes(v!);
    }
    if (message.timestampMs !== 0) {
      writer.uint32(24).uint64(message.timestampMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TOutputPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTOutputPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consolidatedResponseCiphertext = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestProofStreams.push(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestampMs = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TOutputPayload {
    return {
      consolidatedResponseCiphertext: isSet(object.consolidatedResponseCiphertext)
        ? bytesFromBase64(object.consolidatedResponseCiphertext)
        : new Uint8Array(0),
      requestProofStreams: globalThis.Array.isArray(object?.requestProofStreams)
        ? object.requestProofStreams.map((e: any) => bytesFromBase64(e))
        : [],
      timestampMs: isSet(object.timestampMs) ? globalThis.Number(object.timestampMs) : 0,
    };
  },

  toJSON(message: TOutputPayload): unknown {
    const obj: any = {};
    if (message.consolidatedResponseCiphertext.length !== 0) {
      obj.consolidatedResponseCiphertext = base64FromBytes(message.consolidatedResponseCiphertext);
    }
    if (message.requestProofStreams?.length) {
      obj.requestProofStreams = message.requestProofStreams.map((e) => base64FromBytes(e));
    }
    if (message.timestampMs !== 0) {
      obj.timestampMs = Math.round(message.timestampMs);
    }
    return obj;
  },

  create(base?: DeepPartial<TOutputPayload>): TOutputPayload {
    return TOutputPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TOutputPayload>): TOutputPayload {
    const message = createBaseTOutputPayload();
    message.consolidatedResponseCiphertext = object.consolidatedResponseCiphertext ?? new Uint8Array(0);
    message.requestProofStreams = object.requestProofStreams?.map((e) => e) || [];
    message.timestampMs = object.timestampMs ?? 0;
    return message;
  },
};

function createBaseAttestationReport(): AttestationReport {
  return { type: "", report: new Uint8Array(0) };
}

export const AttestationReport: MessageFns<AttestationReport> = {
  encode(message: AttestationReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.report.length !== 0) {
      writer.uint32(18).bytes(message.report);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttestationReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttestationReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.report = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttestationReport {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      report: isSet(object.report) ? bytesFromBase64(object.report) : new Uint8Array(0),
    };
  },

  toJSON(message: AttestationReport): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.report.length !== 0) {
      obj.report = base64FromBytes(message.report);
    }
    return obj;
  },

  create(base?: DeepPartial<AttestationReport>): AttestationReport {
    return AttestationReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttestationReport>): AttestationReport {
    const message = createBaseAttestationReport();
    message.type = object.type ?? "";
    message.report = object.report ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSignedMessage(): SignedMessage {
  return {
    bodyType: 0,
    body: new Uint8Array(0),
    ethAddress: new Uint8Array(0),
    signature: new Uint8Array(0),
    attestationReport: undefined,
  };
}

export const SignedMessage: MessageFns<SignedMessage> = {
  encode(message: SignedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bodyType !== 0) {
      writer.uint32(8).int32(message.bodyType);
    }
    if (message.body.length !== 0) {
      writer.uint32(18).bytes(message.body);
    }
    if (message.ethAddress.length !== 0) {
      writer.uint32(26).bytes(message.ethAddress);
    }
    if (message.signature.length !== 0) {
      writer.uint32(34).bytes(message.signature);
    }
    if (message.attestationReport !== undefined) {
      AttestationReport.encode(message.attestationReport, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bodyType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ethAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.attestationReport = AttestationReport.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedMessage {
    return {
      bodyType: isSet(object.bodyType) ? bodyTypeFromJSON(object.bodyType) : 0,
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
      ethAddress: isSet(object.ethAddress) ? bytesFromBase64(object.ethAddress) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      attestationReport: isSet(object.attestationReport)
        ? AttestationReport.fromJSON(object.attestationReport)
        : undefined,
    };
  },

  toJSON(message: SignedMessage): unknown {
    const obj: any = {};
    if (message.bodyType !== 0) {
      obj.bodyType = bodyTypeToJSON(message.bodyType);
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.ethAddress.length !== 0) {
      obj.ethAddress = base64FromBytes(message.ethAddress);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.attestationReport !== undefined) {
      obj.attestationReport = AttestationReport.toJSON(message.attestationReport);
    }
    return obj;
  },

  create(base?: DeepPartial<SignedMessage>): SignedMessage {
    return SignedMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedMessage>): SignedMessage {
    const message = createBaseSignedMessage();
    message.bodyType = object.bodyType ?? 0;
    message.body = object.body ?? new Uint8Array(0);
    message.ethAddress = object.ethAddress ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.attestationReport = (object.attestationReport !== undefined && object.attestationReport !== null)
      ? AttestationReport.fromPartial(object.attestationReport)
      : undefined;
    return message;
  },
};

function createBaseOPRFVerificationData(): OPRFVerificationData {
  return { streamPos: 0, streamLength: 0, publicSignalsJson: new Uint8Array(0) };
}

export const OPRFVerificationData: MessageFns<OPRFVerificationData> = {
  encode(message: OPRFVerificationData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streamPos !== 0) {
      writer.uint32(8).uint32(message.streamPos);
    }
    if (message.streamLength !== 0) {
      writer.uint32(16).uint32(message.streamLength);
    }
    if (message.publicSignalsJson.length !== 0) {
      writer.uint32(26).bytes(message.publicSignalsJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OPRFVerificationData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOPRFVerificationData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.streamPos = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.streamLength = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicSignalsJson = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OPRFVerificationData {
    return {
      streamPos: isSet(object.streamPos) ? globalThis.Number(object.streamPos) : 0,
      streamLength: isSet(object.streamLength) ? globalThis.Number(object.streamLength) : 0,
      publicSignalsJson: isSet(object.publicSignalsJson)
        ? bytesFromBase64(object.publicSignalsJson)
        : new Uint8Array(0),
    };
  },

  toJSON(message: OPRFVerificationData): unknown {
    const obj: any = {};
    if (message.streamPos !== 0) {
      obj.streamPos = Math.round(message.streamPos);
    }
    if (message.streamLength !== 0) {
      obj.streamLength = Math.round(message.streamLength);
    }
    if (message.publicSignalsJson.length !== 0) {
      obj.publicSignalsJson = base64FromBytes(message.publicSignalsJson);
    }
    return obj;
  },

  create(base?: DeepPartial<OPRFVerificationData>): OPRFVerificationData {
    return OPRFVerificationData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OPRFVerificationData>): OPRFVerificationData {
    const message = createBaseOPRFVerificationData();
    message.streamPos = object.streamPos ?? 0;
    message.streamLength = object.streamLength ?? 0;
    message.publicSignalsJson = object.publicSignalsJson ?? new Uint8Array(0);
    return message;
  },
};

function createBaseVerificationBundle(): VerificationBundle {
  return { teekSigned: undefined, teetSigned: undefined, oprfVerifications: [] };
}

export const VerificationBundle: MessageFns<VerificationBundle> = {
  encode(message: VerificationBundle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teekSigned !== undefined) {
      SignedMessage.encode(message.teekSigned, writer.uint32(10).fork()).join();
    }
    if (message.teetSigned !== undefined) {
      SignedMessage.encode(message.teetSigned, writer.uint32(18).fork()).join();
    }
    for (const v of message.oprfVerifications) {
      OPRFVerificationData.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerificationBundle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerificationBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.teekSigned = SignedMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.teetSigned = SignedMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oprfVerifications.push(OPRFVerificationData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerificationBundle {
    return {
      teekSigned: isSet(object.teekSigned) ? SignedMessage.fromJSON(object.teekSigned) : undefined,
      teetSigned: isSet(object.teetSigned) ? SignedMessage.fromJSON(object.teetSigned) : undefined,
      oprfVerifications: globalThis.Array.isArray(object?.oprfVerifications)
        ? object.oprfVerifications.map((e: any) => OPRFVerificationData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VerificationBundle): unknown {
    const obj: any = {};
    if (message.teekSigned !== undefined) {
      obj.teekSigned = SignedMessage.toJSON(message.teekSigned);
    }
    if (message.teetSigned !== undefined) {
      obj.teetSigned = SignedMessage.toJSON(message.teetSigned);
    }
    if (message.oprfVerifications?.length) {
      obj.oprfVerifications = message.oprfVerifications.map((e) => OPRFVerificationData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VerificationBundle>): VerificationBundle {
    return VerificationBundle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VerificationBundle>): VerificationBundle {
    const message = createBaseVerificationBundle();
    message.teekSigned = (object.teekSigned !== undefined && object.teekSigned !== null)
      ? SignedMessage.fromPartial(object.teekSigned)
      : undefined;
    message.teetSigned = (object.teetSigned !== undefined && object.teetSigned !== null)
      ? SignedMessage.fromPartial(object.teetSigned)
      : undefined;
    message.oprfVerifications = object.oprfVerifications?.map((e) => OPRFVerificationData.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
